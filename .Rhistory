output = array(0, c(1, nrow(points)))
for (i in 1:nrow(points))
output[,i] = -ifelse((points[i,1]^2+points[i,2]^2)<1,100,0)
output
}
# plot the forcing funcion
xgrid=seq(from=-3,to=3,by=0.1)
ygrid=seq(from=-3,to=3,by=0.1)
image(xgrid,ygrid,matrix(u_func(expand.grid(xgrid,ygrid)),nrow=length(xgrid),ncol=length(ygrid),byrow=FALSE),main='forcing function',asp=1)
lines(mesh$nodes[1:50,])
PDE_parameters = list(K = K_func, b = b_func, c = c_func, u = u_func)
output_CPP<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
lambda=lambda,
BC = BC,
PDE_parameters = PDE_parameters,
lambda.selection.criterion='grid', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
plot(output_CPP$fit.FEM)
#### Test 4.2.3: Forcing term != 0 grid with stochastic GCV
# forcing function != 0
u_func<-function(points)
{
output = array(0, c(1, nrow(points)))
for (i in 1:nrow(points))
output[,i] = -ifelse((points[i,1]^2+points[i,2]^2)<1,100,0)
output
}
# plot the forcing funcion
xgrid=seq(from=-3,to=3,by=0.1)
ygrid=seq(from=-3,to=3,by=0.1)
image(xgrid,ygrid,matrix(u_func(expand.grid(xgrid,ygrid)),nrow=length(xgrid),ncol=length(ygrid),byrow=FALSE),main='forcing function',asp=1)
lines(mesh$nodes[1:50,])
PDE_parameters = list(K = K_func, b = b_func, c = c_func, u = u_func)
output_CPP<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
lambda=lambda,
BC = BC,
PDE_parameters = PDE_parameters,
lambda.selection.criterion='grid', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV')
plot(output_CPP$fit.FEM)
#### Test 4.2.4: Forcing term != 0 Newton finite differences with exact GCV
# forcing function != 0
u_func<-function(points)
{
output = array(0, c(1, nrow(points)))
for (i in 1:nrow(points))
output[,i] = -ifelse((points[i,1]^2+points[i,2]^2)<1,100,0)
output
}
# plot the forcing funcion
xgrid=seq(from=-3,to=3,by=0.1)
ygrid=seq(from=-3,to=3,by=0.1)
image(xgrid,ygrid,matrix(u_func(expand.grid(xgrid,ygrid)),nrow=length(xgrid),ncol=length(ygrid),byrow=FALSE),main='forcing function',asp=1)
lines(mesh$nodes[1:50,])
PDE_parameters = list(K = K_func, b = b_func, c = c_func, u = u_func)
output_CPP<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
BC = BC,
PDE_parameters = PDE_parameters,
lambda.selection.criterion='newton_fd', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
plot(output_CPP$fit.FEM)
#### Test 4.2.5: Forcing term != 0 Newton finite differences with stochastic GCV
# forcing function != 0
u_func<-function(points)
{
output = array(0, c(1, nrow(points)))
for (i in 1:nrow(points))
output[,i] = -ifelse((points[i,1]^2+points[i,2]^2)<1,100,0)
output
}
# plot the forcing funcion
xgrid=seq(from=-3,to=3,by=0.1)
ygrid=seq(from=-3,to=3,by=0.1)
image(xgrid,ygrid,matrix(u_func(expand.grid(xgrid,ygrid)),nrow=length(xgrid),ncol=length(ygrid),byrow=FALSE),main='forcing function',asp=1)
lines(mesh$nodes[1:50,])
PDE_parameters = list(K = K_func, b = b_func, c = c_func, u = u_func)
output_CPP<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
BC = BC,
PDE_parameters = PDE_parameters,
lambda.selection.criterion='newton_fd', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV')
plot(output_CPP$fit.FEM)
#### Test 4.3.1: BC != 0      without GCV
# Add a constat to the data to change true BC
data_backup=data #save a copy of original data
data = data + 5
# Set new value for the BC
BC$BC_values = rep(5,length(BC$BC_indices))
output_CPP<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
lambda=lambda,
BC = BC,
PDE_parameters = PDE_parameters)
data=data_backup #restore original data for next tests
plot(output_CPP$fit.FEM)
#### Test 4.3.2: BC != 0      grid with exact GCV
# Add a constat to the data to change true BC
data_backup=data #save a copy of original data
data = data + 5
# Set new value for the BC
BC$BC_values = rep(5,length(BC$BC_indices))
output_CPP<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
lambda=lambda,
BC = BC,
PDE_parameters = PDE_parameters,
lambda.selection.criterion='grid', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
data=data_backup #restore original data for next tests
plot(output_CPP$fit.FEM)
#### Test 4.3.3: BC != 0      grid with stochastic GCV
# Add a constat to the data to change true BC
data_backup=data #save a copy of original data
data = data + 5
# Set new value for the BC
BC$BC_values = rep(5,length(BC$BC_indices))
output_CPP<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
lambda=lambda,
BC = BC,
PDE_parameters = PDE_parameters,
lambda.selection.criterion='grid', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV')
data=data_backup #restore original data for next tests
plot(output_CPP$fit.FEM)
#### Test 4.3.4: BC != 0     Newton Finite differences with exact GCV
# Add a constat to the data to change true BC
data_backup=data #save a copy of original data
data = data + 5
# Set new value for the BC
BC$BC_values = rep(5,length(BC$BC_indices))
output_CPP<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
BC = BC,
PDE_parameters = PDE_parameters,
lambda.selection.criterion='newton_fd', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
data=data_backup #restore original data for next tests
plot(output_CPP$fit.FEM)
#### Test 4.3.5: BC != 0     Newton Finite differences with stochastic GCV
# Add a constat to the data to change true BC
data_backup=data #save a copy of original data
data = data + 5
# Set new value for the BC
BC$BC_values = rep(5,length(BC$BC_indices))
output_CPP<-smooth.FEM(observations=data,
incidence_matrix = incidence_matrix,
FEMbasis=FEMbasis,
BC = BC,
PDE_parameters = PDE_parameters,
lambda.selection.criterion='newton_fd', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV')
data=data_backup #restore original data for next tests
plot(output_CPP$fit.FEM)
library(fdaPDE)
####### 2D ########
#### Test 1: square domain ####
#            locations = nodes
#            laplacian
#            no covariates
#            no BC
#            order FE = 1
rm(list=ls())
graphics.off()
x = seq(0,1, length.out = 60)
y = x
locations = expand.grid(x,y)
mesh = create.mesh.2D(locations)
plot(mesh)
nnodes = dim(mesh$nodes)[1]
FEMbasis = create.FEM.basis(mesh)
# Test function
f = function(x, y, z = 1)
{
coe = function(x,y) 1/2*sin(5*pi*x)*exp(-x^2)+1
sin(2*pi*(coe(y,1)*x*cos(z-2)-y*sin(z-2)))*cos(2*pi*(coe(y,1)*x*cos(z-2+pi/2)+coe(x,1)*y*sin((z-2)*pi/2)))
}
# Exact solution (pointwise at nodes)
sol_exact = f(mesh$nodes[,1], mesh$nodes[,2])
image(FEM(sol_exact, FEMbasis))
# Add error to simulate data
set.seed(7893475)
ran = range(sol_exact)
data = sol_exact + rnorm(nnodes, mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda = 10^seq(-6,-6,by=0.25)
#### Test 1.1: Without GCV
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda)
image(output_CPP$fit.FEM)
#### Test 1.2: grid with exact GCV
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda, lambda.selection.criterion='grid', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
plot(log10(lambda), output_CPP$optimization$GCV_vector)
image(FEM(output_CPP$fit.FEM$coeff,FEMbasis))
#### Test 1.3: grid with stochastic GCV
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda, lambda.selection.criterion='grid', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV', DOF.stochastic.realizations = 1000)
plot(log10(lambda), output_CPP$optimization$GCV_vector)
image(FEM(output_CPP$fit.FEM$coeff,FEMbasis))
### Test 1.4: Newton exact method with exact GCV, default initial lambda and tolerance
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda.selection.criterion='newton', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
### Test 1.5: Newton_fd method with  exact GCV, default initial lambda and tolerance
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda.selection.criterion='newton_fd', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
### Test 1.6: Newton_fd method with stochastic GCV, default initial lambda and tolerance
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda.selection.criterion='newton_fd', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV')
### Test 1.6: Newton_fd method with stochastic GCV, default initial lambda and tolerance
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda.selection.criterion='newton_fd', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV')
### Test 1.6: Newton_fd method with stochastic GCV, default initial lambda and tolerance
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda.selection.criterion='newton_fd', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV')
### Test 1.6: Newton_fd method with stochastic GCV, default initial lambda and tolerance
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda.selection.criterion='newton_fd', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV')
### Test 1.6: Newton_fd method with stochastic GCV, default initial lambda and tolerance
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda.selection.criterion='newton_fd', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV')
library(fdaPDE)
#### Test 1: C-shaped domain ####
#            locations = nodes
#            no covariates
#            no BC
#            order FE = 1
rm(list=ls())
graphics.off()
data(horseshoe2.5D)
mesh = horseshoe2.5D
nnodes=dim(mesh$nodes)[1]
FEMbasis=create.FEM.basis(mesh)
# Exact solution (pointwise at nodes)
sol_exact=fs.test.3D(mesh$nodes[,1],mesh$nodes[,3],mesh$nodes[,2])
plot(FEM(sol_exact, FEMbasis))
# Add error to simulate data
set.seed(7893475)
ran=range(sol_exact)
data = sol_exact + rnorm(nnodes, mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda = 10^seq(-2,0.5,by=0.25)
#### Test 1.1: Without GCV
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda)
plot(output_CPP$fit.FEM)
# mesh = horseshoe2.5D
mesh = create.mesh.2.5D(horseshoe2.5D$nodes, horseshoe2.5D$triangles)
nnodes=dim(mesh$nodes)[1]
FEMbasis=create.FEM.basis(mesh)
# Exact solution (pointwise at nodes)
sol_exact=fs.test.3D(mesh$nodes[,1],mesh$nodes[,3],mesh$nodes[,2])
plot(FEM(sol_exact, FEMbasis))
# Add error to simulate data
set.seed(7893475)
ran=range(sol_exact)
data = sol_exact + rnorm(nnodes, mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda = 10^seq(-2,0.5,by=0.25)
#### Test 1.1: Without GCV
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda)
FEMbasis=create.FEM.basis(mesh)
# Exact solution (pointwise at nodes)
sol_exact=fs.test.3D(mesh$nodes[,1],mesh$nodes[,3],mesh$nodes[,2])
# Add error to simulate data
set.seed(7893475)
ran=range(sol_exact)
data = sol_exact + rnorm(nnodes, mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda = 10^seq(-2,0.5,by=0.25)
#### Test 1.1: Without GCV
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda)
library(fdaPDE)
#### Test 1: C-shaped domain ####
#            locations = nodes
#            no covariates
#            no BC
#            order FE = 1
rm(list=ls())
graphics.off()
data(horseshoe2.5D)
# mesh = horseshoe2.5D
mesh = create.mesh.2.5D(horseshoe2.5D$nodes, horseshoe2.5D$triangles)
nnodes=dim(mesh$nodes)[1]
FEMbasis=create.FEM.basis(mesh)
# Exact solution (pointwise at nodes)
sol_exact=fs.test.3D(mesh$nodes[,1],mesh$nodes[,3],mesh$nodes[,2])
plot(FEM(sol_exact, FEMbasis))
# Add error to simulate data
set.seed(7893475)
ran=range(sol_exact)
data = sol_exact + rnorm(nnodes, mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda = 10^seq(-2,0.5,by=0.25)
#### Test 1.1: Without GCV
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda)
library(fdaPDE)
####### 2.5D ########
#### Test 1: C-shaped domain ####
#            locations = nodes
#            no covariates
#            no BC
#            order FE = 1
rm(list=ls())
graphics.off()
data(horseshoe2.5D)
# mesh = horseshoe2.5D
mesh = create.mesh.2.5D(horseshoe2.5D$nodes, horseshoe2.5D$triangles)
nnodes=dim(mesh$nodes)[1]
FEMbasis=create.FEM.basis(mesh)
# Exact solution (pointwise at nodes)
sol_exact=fs.test.3D(mesh$nodes[,1],mesh$nodes[,3],mesh$nodes[,2])
plot(FEM(sol_exact, FEMbasis))
# Add error to simulate data
set.seed(7893475)
ran=range(sol_exact)
data = sol_exact + rnorm(nnodes, mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda = 10^seq(-2,0.5,by=0.25)
#### Test 1.1: Without GCV
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda)
plot(output_CPP$fit.FEM)
lambda.selection.criterion='grid', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV')
plot(log10(lambda), output_CPP$optimization$GCV_vector)
plot(FEM(output_CPP$fit.FEM$coeff,FEMbasis))
plot(log10(lambda), output_CPP$optimization$GCV_vector)
lambda
output_CPP$optimization$GCV_vector
##########################################
############## TEST SCRIPT ###############
##########################################
library(currentfdaPDE)
####### 2.5D ########
#### Test 1: C-shaped domain ####
#            locations = nodes
#            no covariates
#            no BC
#            order FE = 1
rm(list=ls())
graphics.off()
data(horseshoe2.5D)
# mesh = horseshoe2.5D
mesh = create.mesh.2.5D(horseshoe2.5D$nodes, horseshoe2.5D$triangles)
nnodes=dim(mesh$nodes)[1]
FEMbasis=create.FEM.basis(mesh)
# Exact solution (pointwise at nodes)
sol_exact=fs.test.3D(mesh$nodes[,1],mesh$nodes[,3],mesh$nodes[,2])
plot(FEM(sol_exact, FEMbasis))
# Add error to simulate data
set.seed(7893475)
ran=range(sol_exact)
data = sol_exact + rnorm(nnodes, mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda = 10^seq(-2,0.5,by=0.25)
#### Test 1.1: Without GCV
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda)
plot(output_CPP$fit.FEM)
lambda.selection.criterion='grid', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV')
plot(log10(lambda), output_CPP$optimization$GCV_vector)
plot(FEM(output_CPP$fit.FEM$coeff,FEMbasis))
#            locations != nodes
#            with covariates
#            no BC
#            order FE = 1
rm(list=ls())
graphics.off()
data(sphere2.5D)
mesh = sphere2.5D
FEMbasis=create.FEM.basis(mesh)
# Test function
f = function(x, y, z){
phi = (asin(y/sqrt(x^2+y^2)))
theta = acos(z/sqrt(x^2+y^2+z^2))
# rho = 1
sin(4*(1/2*sin(theta)*exp(-sin(theta)^2)+1)*theta)*cos(2*(1/2*cos(phi)*exp(-cos(phi)^2)+1)*phi)
}
# Exact solution (pointwise at nodes)
sol_exact=f(mesh$nodes[,1], mesh$nodes[,2], mesh$nodes[,3])
plot(FEM(sol_exact, FEMbasis))
# Generate data locations on the sphere
set.seed(598944)
ndata = 500
locations = matrix(rnorm(ndata*3), ncol = 3)
locations = locations/sqrt(locations[,1]^2 + locations[,2]^2 + locations[,3]^2)
# Generate covariate and data
cov1 = runif(ndata, min = -1, max = 1)
DatiEsatti = f(locations[,1],locations[,2], locations[,3]) + cov1
# Add error to simulate data
set.seed(7893475)
ran=range(DatiEsatti)
data = DatiEsatti + rnorm(ndata, mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Project locations on the mesh
projected_locations = projection.points.2.5D(mesh, locations)
# Set smoothing parameter
lambda = 10^seq(-4,-2,by=0.25)
#### Test 2.1: Without GCV
output_CPP<-smooth.FEM(observations=data,
locations = projected_locations,
covariates = cov1,
FEMbasis=FEMbasis,
lambda=lambda[1])
plot(output_CPP$fit.FEM)
output_CPP$solution$beta
#### Test 2.2: grid with exact GCV
output_CPP<-smooth.FEM(observations=data, locations = projected_locations,
covariates = cov1,
FEMbasis=FEMbasis, lambda=lambda,
lambda.selection.criterion='grid', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
plot(log10(lambda), output_CPP$optimization$GCV_vector)
plot(FEM(output_CPP$fit.FEM$coeff,FEMbasis))
output_CPP$solution$beta
#### Test 2.3: grid with stochastic GCV
output_CPP<-smooth.FEM(observations=data, locations = projected_locations,
covariates = cov1,
FEMbasis=FEMbasis, lambda=lambda,
lambda.selection.criterion='grid', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV')
plot(log10(lambda), output_CPP$optimization$GCV_vector)
plot(FEM(output_CPP$fit.FEM$coeff,FEMbasis))
output_CPP$solution$beta
#### Test 2.4: Newton method with exact GCV, default initial lambda and tolerance
output_CPP<-smooth.FEM(observations=data, locations = projected_locations,
covariates = cov1,
FEMbasis=FEMbasis,
lambda.selection.criterion='newton', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
plot(FEM(output_CPP$fit.FEM$coeff,FEMbasis))
output_CPP$solution$beta
#### Test 2.5: Newton_fd method with exact GCV, default initial lambda and tolerance
output_CPP<-smooth.FEM(observations=data, locations = projected_locations,
covariates = cov1,
FEMbasis=FEMbasis,
lambda.selection.criterion='newton_fd', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
plot(FEM(output_CPP$fit.FEM$coeff,FEMbasis))
output_CPP$solution$beta
#### Test 2.6: Newton_fd method with stochastic GCV, default initial lambda and tolerance
output_CPP<-smooth.FEM(observations=data, locations = projected_locations,
covariates = cov1,
FEMbasis=FEMbasis,
lambda.selection.criterion='newton_fd', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV')
plot(FEM(output_CPP$fit.FEM$coeff,FEMbasis))
output_CPP$solution$beta
#### Test 1: C-shaped domain ####
#            locations = nodes
#            no covariates
#            no BC
#            order FE = 1
rm(list=ls())
graphics.off()
data(horseshoe2.5D)
# mesh = horseshoe2.5D
mesh = create.mesh.2.5D(horseshoe2.5D$nodes, horseshoe2.5D$triangles)
nnodes=dim(mesh$nodes)[1]
FEMbasis=create.FEM.basis(mesh)
# Exact solution (pointwise at nodes)
sol_exact=fs.test.3D(mesh$nodes[,1],mesh$nodes[,3],mesh$nodes[,2])
plot(FEM(sol_exact, FEMbasis))
# Add error to simulate data
set.seed(7893475)
ran=range(sol_exact)
data = sol_exact + rnorm(nnodes, mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda = 10^seq(-2,0.5,by=0.25)
#### Test 1.1: Without GCV
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda)
#### Test 1.2: grid with exact GCV
#it takes a lot of time
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda,
lambda.selection.criterion='grid', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
plot(log10(lambda), output_CPP$optimization$GCV_vector)
#### Test 1.3: grid with stochastic GCV
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda,
lambda.selection.criterion='grid', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV')
plot(log10(lambda), output_CPP$optimization$GCV_vector)
library(fdaPDE)
#### Test 1: C-shaped domain ####
#            locations = nodes
#            no covariates
#            no BC
#            order FE = 1
rm(list=ls())
graphics.off()
data(horseshoe2.5D)
# mesh = horseshoe2.5D
mesh = create.mesh.2.5D(horseshoe2.5D$nodes, horseshoe2.5D$triangles)
nnodes=dim(mesh$nodes)[1]
FEMbasis=create.FEM.basis(mesh)
# Exact solution (pointwise at nodes)
sol_exact=fs.test.3D(mesh$nodes[,1],mesh$nodes[,3],mesh$nodes[,2])
plot(FEM(sol_exact, FEMbasis))
# Add error to simulate data
set.seed(7893475)
ran=range(sol_exact)
data = sol_exact + rnorm(nnodes, mean=0, sd=0.05*abs(ran[2]-ran[1]))
# Set smoothing parameter
lambda = 10^seq(-2,0.5,by=0.25)
#### Test 1.1: Without GCV
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda)
#### Test 1.2: grid with exact GCV
#it takes a lot of time
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda,
lambda.selection.criterion='grid', DOF.evaluation='exact', lambda.selection.lossfunction='GCV')
plot(log10(lambda), output_CPP$optimization$GCV_vector)
#### Test 1.3: grid with stochastic GCV
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda,
lambda.selection.criterion='grid', DOF.evaluation='stochastic', lambda.selection.lossfunction='GCV')
plot(log10(lambda), output_CPP$optimization$GCV_vector)
plot(log10(lambda), output_CPP$optimization$GCV_vector)
plot(log10(lambda), output_CPP$optimization$GCV_vector)
library(currentfdaPDE)
data(sphere2.5D)
data(sphere3D)
data(sphere3Ddata)
install.packages("Directional")
install.packages("Rfast")
install.packages("Rfast")
install.packages("Directional")
setwd("~/Desktop/PACS/Progetto/fdaPDE")
roxygen2::roxygenise()
1+
2
