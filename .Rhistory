walktimesold<-NULL
naivetimesold<-NULL
for(j in 1:10){
loc=matrix(data=runif(2*nloc, min=min(nodes),max=max(nodes)),nrow=nloc,ncol=2,byrow=T)
nloc = 2*nloc
for(i in 1:N){
mytimenaive[i]<-system.time(eval.FEM(output_CPP$fit.FEM,locations=loc, search="naive"))["elapsed"]
# mytimewalkold[i]<-system.time(eval.FEM(output_CPP$fit.FEM,locations=loc, search="walking"))["elapsed"]
# mytimetreeold[i]<-system.time(eval.FEM(output_tree$fit.FEM,locations=loc, search="tree"))["elapsed"]
# mytimenewtreeold[i]<-system.time(eval.FEM(output_CPP$fit.FEM,locations=loc, search="tree"))["elapsed"]
}
treetimesold<-cbind(treetimesold, mytimetreeold)
newtreetimesold<-cbind(newtreetimesold, mytimenewtreeold)
walktimesold<-cbind(walktimesold, mytimewalkold)
naivetimesold<-cbind(naivetimesold, mytimenaiveold)
}
xvals<-log10(100*2^(0:9))
names(xvals)<-c("100","200","400","800","1600","3200","6400","12800","25600","51200")
plot(xvals, log10(apply(walktimes,2,median)),
ylim=range(log10(apply(walktimes,2,median)), log10(apply(walktimesold,2,median))),
type="l", col="black",xaxt = "n",xlab="#points to search", ylab="median time")
axis(1, at=xvals, labels=names(xvals))
lines(xvals, log10(apply(treetimes,2,median)), col="red")
lines(xvals, log10(apply(newtreetimes,2,median)), col="blue")
lines(xvals, log10(apply(treetimesold,2,median)), col="green")
lines(xvals, log10(apply(newtreetimesold,2,median)), col="orange")
lines(xvals, log10(apply(walktimesold,2,median)), col="gray")
lines(xvals, log10(apply(naivetimes,2,median)), col="yellow")
lines(xvals, log10(apply(naivetimesold,2,median)), col="blue")
legend("bottomright", legend=c("walk", "tree","tree0","old_tree","old_tree0", "old_walk"),
fill=c("black", "red","blue","green","orange", "gray"),cex=0.8)
log10(apply(walktimes,2,median))-log10(apply(walktimesold,2,median))
detach("package:currentfdaPDE", unload = TRUE)
library(fdaPDE)
rm(list=ls())
split.mesh.2D <- function (mesh=NULL){
if(is.null(mesh))
stop("No mesh passed as input!")
if(class(mesh)!='mesh.2D')
stop("Wrong mesh class! Should be mesh.2D")
# Indexes in C++ starts from 0, in R from 1, needed transformations!
mesh$triangles = mesh$triangles - 1
storage.mode(mesh$triangles) <- "integer"
storage.mode(mesh$nodes) <- "double"
if(mesh$order==1){
outCPP <- .Call("CPP_TriangleMeshSplit", mesh$triangles[,1:3], mesh$nodes)
splittedmesh<-create.mesh.2D(nodes=rbind(mesh$nodes, outCPP[[2]]), triangles=outCPP[[1]])
}
else if(mesh$order==2){
outCPP <- .Call("CPP_TriangleMeshSplitOrder2", mesh$triangles[,1:3], mesh$nodes)
splittedmesh<-create.mesh.2D(nodes=mesh$nodes, triangles=outCPP[[1]], order=2)
}
return(splittedmesh)
}
load("~/Desktop/PACS/Progetto/pacsColliColombo/data/square2Ddata.RData")
mesh=create.mesh.2D(nodes=nodes)
for(i in 1:1){
mesh<-split.mesh.2D(mesh)
}
# x11()
# axis(1)
# axis(2)
nnodes=dim(mesh$nodes)[1]
FEMbasis=create.FEM.basis(mesh)
# Test function
set.seed(5847947)
a1=runif(1,min=-1.5,max=1.5)
a2=runif(1,min=-1.5,max=1.5)
z<-function(p)
{
a1*sin(2*pi*p[1])*cos(2*pi*p[2])+a2*sin(3*pi*p[1])
}
# Exact solution (pointwise at nodes)
sol_exact=rep(0,dim(mesh$nodes)[1])
for(i in 1: dim(mesh$nodes)[1])
sol_exact[i]=z(mesh$nodes[i,])
ran=range(sol_exact)
# Set smoothing parameter
lambda= 10^-3
GCVFLAG=T
GCVMETHODFLAG='Exact'
data = sol_exact + rnorm(nnodes, mean=0, sd=0.05*(ran[2]-ran[1]))
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda,
GCV=GCVFLAG, GCVmethod = GCVMETHODFLAG,search="naive")
output_tree<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda,
GCV=GCVFLAG, GCVmethod = GCVMETHODFLAG)
N<-50
mytimenaive<-vector(mode="numeric", N)
mytimetree<-vector(mode="numeric", N)
mytimenewtree<-vector(mode="numeric", N)
mytimewalk<-vector(mode="numeric", N)
nloc = 100
treetimes<-NULL
newtreetimes<-NULL
walktimes<-NULL
naivetimes<-NULL
for(j in 1:10){
# Generate locations
loc=matrix(data=runif(2*nloc, min=min(nodes),max=max(nodes)),nrow=nloc,ncol=2,byrow=T)
nloc = 2*nloc
for(i in 1:N){
mytimenaive[i]<-system.time(eval.FEM(output_CPP$fit.FEM,locations=loc, search="naive"))["elapsed"]
# mytimewalk[i]<-system.time(eval.FEM(output_CPP$fit.FEM,locations=loc, search="walking"))["elapsed"]
# mytimetree[i]<-system.time(eval.FEM(output_tree$fit.FEM,locations=loc, search="tree"))["elapsed"]
# mytimenewtree[i]<-system.time(eval.FEM(output_CPP$fit.FEM,locations=loc, search="tree"))["elapsed"]
}
treetimes<-cbind(treetimes, mytimetree)
newtreetimes<-cbind(newtreetimes, mytimenewtree)
walktimes<-cbind(walktimes, mytimewalk)
naivetimes<-cbind(naivetimes, mytimenaive)
}
rm(list=setdiff(ls(), c("mesh","treetimes","newtreetimes","walktimes")))
detach("package:fdaPDE", unload = TRUE)
library(currentfdaPDE)
load("~/Desktop/PACS/Progetto/pacsColliColombo/data/square2Ddata.RData")
mesh=create.mesh.2D(nodes=mesh$nodes, triangle=mesh$triangles)
# x11()
# axis(1)
# axis(2)
nnodes=dim(mesh$nodes)[1]
FEMbasis=create.FEM.basis(mesh)
# Test function
set.seed(5847947)
a1=runif(1,min=-1.5,max=1.5)
a2=runif(1,min=-1.5,max=1.5)
z<-function(p)
{
a1*sin(2*pi*p[1])*cos(2*pi*p[2])+a2*sin(3*pi*p[1])
}
# Exact solution (pointwise at nodes)
sol_exact=rep(0,dim(mesh$nodes)[1])
for(i in 1: dim(mesh$nodes)[1])
sol_exact[i]=z(mesh$nodes[i,])
ran=range(sol_exact)
# Set smoothing parameter
lambda= 10^-3
GCVFLAG=T
GCVMETHODFLAG='Exact'
data = sol_exact + rnorm(nnodes, mean=0, sd=0.05*(ran[2]-ran[1]))
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda,
GCV=GCVFLAG, GCVmethod = GCVMETHODFLAG,search="naive")
output_tree<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda,
GCV=GCVFLAG, GCVmethod = GCVMETHODFLAG)
output_CPP$fit.FEM$FEMbasis<-FEMbasis
N<-50
mytimenaiveold<-vector(mode="numeric", N)
mytimewalkold<-vector(mode="numeric", N)
mytimetreeold<-vector(mode="numeric", N)
mytimenewtreeold<-vector(mode="numeric", N)
nloc = 100
treetimesold<-NULL
newtreetimesold<-NULL
walktimesold<-NULL
naivetimesold<-NULL
for(j in 1:10){
loc=matrix(data=runif(2*nloc, min=min(nodes),max=max(nodes)),nrow=nloc,ncol=2,byrow=T)
nloc = 2*nloc
for(i in 1:N){
mytimenaiveold[i]<-system.time(eval.FEM(output_CPP$fit.FEM,locations=loc, search="naive"))["elapsed"]
# mytimewalkold[i]<-system.time(eval.FEM(output_CPP$fit.FEM,locations=loc, search="walking"))["elapsed"]
# mytimetreeold[i]<-system.time(eval.FEM(output_tree$fit.FEM,locations=loc, search="tree"))["elapsed"]
# mytimenewtreeold[i]<-system.time(eval.FEM(output_CPP$fit.FEM,locations=loc, search="tree"))["elapsed"]
}
treetimesold<-cbind(treetimesold, mytimetreeold)
newtreetimesold<-cbind(newtreetimesold, mytimenewtreeold)
walktimesold<-cbind(walktimesold, mytimewalkold)
naivetimesold<-cbind(naivetimesold, mytimenaiveold)
}
xvals<-log10(100*2^(0:9))
names(xvals)<-c("100","200","400","800","1600","3200","6400","12800","25600","51200")
plot(xvals, log10(apply(walktimes,2,median)),
ylim=range(log10(apply(walktimes,2,median)), log10(apply(walktimesold,2,median))),
type="l", col="black",xaxt = "n",xlab="#points to search", ylab="median time")
axis(1, at=xvals, labels=names(xvals))
lines(xvals, log10(apply(treetimes,2,median)), col="red")
lines(xvals, log10(apply(newtreetimes,2,median)), col="blue")
lines(xvals, log10(apply(treetimesold,2,median)), col="green")
lines(xvals, log10(apply(newtreetimesold,2,median)), col="orange")
lines(xvals, log10(apply(walktimesold,2,median)), col="gray")
plot(xvals, log10(apply(naivetimes,2,median)), col="yellow",
ylim=range(log10(apply(naivetimes,2,median)), log10(apply(naivetimesold,2,median))))
lines(xvals, log10(apply(naivetimesold,2,median)), col="blue")
legend("bottomright", legend=c("walk", "tree","tree0","old_tree","old_tree0", "old_walk"),
fill=c("black", "red","blue","green","orange", "gray"),cex=0.8)
# log10(apply(walktimes,2,median))-log10(apply(walktimesold,2,median))
detach("package:currentfdaPDE", unload = TRUE)
library(fdaPDE)
split.mesh.2D <- function (mesh=NULL){
if(is.null(mesh))
stop("No mesh passed as input!")
if(class(mesh)!='mesh.2D')
stop("Wrong mesh class! Should be mesh.2D")
# Indexes in C++ starts from 0, in R from 1, needed transformations!
mesh$triangles = mesh$triangles - 1
storage.mode(mesh$triangles) <- "integer"
storage.mode(mesh$nodes) <- "double"
if(mesh$order==1){
outCPP <- .Call("CPP_TriangleMeshSplit", mesh$triangles[,1:3], mesh$nodes)
splittedmesh<-create.mesh.2D(nodes=rbind(mesh$nodes, outCPP[[2]]), triangles=outCPP[[1]])
}
else if(mesh$order==2){
outCPP <- .Call("CPP_TriangleMeshSplitOrder2", mesh$triangles[,1:3], mesh$nodes)
splittedmesh<-create.mesh.2D(nodes=mesh$nodes, triangles=outCPP[[1]], order=2)
}
return(splittedmesh)
}
load("~/Desktop/PACS/Progetto/pacsColliColombo/data/square2Ddata.RData")
mesh=create.mesh.2D(nodes=nodes)
for(i in 1:1){
mesh<-split.mesh.2D(mesh)
}
nnodes=dim(mesh$nodes)[1]
FEMbasis=create.FEM.basis(mesh)
set.seed(5847947)
a1=runif(1,min=-1.5,max=1.5)
a2=runif(1,min=-1.5,max=1.5)
z<-function(p)
{
a1*sin(2*pi*p[1])*cos(2*pi*p[2])+a2*sin(3*pi*p[1])
}
# Exact solution (pointwise at nodes)
sol_exact=rep(0,dim(mesh$nodes)[1])
for(i in 1: dim(mesh$nodes)[1])
sol_exact[i]=z(mesh$nodes[i,])
ran=range(sol_exact)
lambda= 10^-3
GCVFLAG=T
GCVMETHODFLAG='Exact'
data = sol_exact + rnorm(nnodes, mean=0, sd=0.05*(ran[2]-ran[1]))
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda,
GCV=GCVFLAG, GCVmethod = GCVMETHODFLAG,search="naive")
output_tree<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda,
GCV=GCVFLAG, GCVmethod = GCVMETHODFLAG)
N<-50
mytimenaive<-vector(mode="numeric", N)
mytimetree<-vector(mode="numeric", N)
mytimenewtree<-vector(mode="numeric", N)
mytimewalk<-vector(mode="numeric", N)
nloc = 100
treetimes<-NULL
newtreetimes<-NULL
walktimes<-NULL
naivetimes<-NULL
for(j in 1:10){
# Generate locations
loc=matrix(data=runif(2*nloc, min=min(nodes),max=max(nodes)),nrow=nloc,ncol=2,byrow=T)
nloc = 2*nloc
for(i in 1:N){
mytimenaive[i]<-system.time(eval.FEM(output_CPP$fit.FEM,locations=loc, search="naive"))["elapsed"]
# mytimewalk[i]<-system.time(eval.FEM(output_CPP$fit.FEM,locations=loc, search="walking"))["elapsed"]
# mytimetree[i]<-system.time(eval.FEM(output_tree$fit.FEM,locations=loc, search="tree"))["elapsed"]
# mytimenewtree[i]<-system.time(eval.FEM(output_CPP$fit.FEM,locations=loc, search="tree"))["elapsed"]
}
treetimes<-cbind(treetimes, mytimetree)
newtreetimes<-cbind(newtreetimes, mytimenewtree)
walktimes<-cbind(walktimes, mytimewalk)
naivetimes<-cbind(naivetimes, mytimenaive)
}
plot(xvals, log10(apply(naivetimes,2,median)), col="yellow",
ylim=range(log10(apply(naivetimes,2,median)), log10(apply(naivetimesold,2,median))))
lines(xvals, log10(apply(naivetimesold,2,median)), col="blue")
plot(xvals, log10(apply(naivetimes,2,median)), col="yellow",
type="l", col="black",xaxt = "n",xlab="#points to search", ylab="median time",
ylim=range(log10(apply(naivetimes,2,median)), log10(apply(naivetimesold,2,median))))
plot(xvals, log10(apply(naivetimes,2,median)), col="yellow",
type="l",xaxt = "n",xlab="#points to search", ylab="median time",
ylim=range(log10(apply(naivetimes,2,median)), log10(apply(naivetimesold,2,median))))
lines(xvals, log10(apply(naivetimesold,2,median)), col="blue")
log10(apply(naivetimes,2,median))-log10(apply(naivetimesold,2,median))
detach("package:currentfdaPDE", unload = TRUE)
library(fdaPDE)
rm(list=ls())
split.mesh.2D <- function (mesh=NULL){
if(is.null(mesh))
stop("No mesh passed as input!")
if(class(mesh)!='mesh.2D')
stop("Wrong mesh class! Should be mesh.2D")
# Indexes in C++ starts from 0, in R from 1, needed transformations!
mesh$triangles = mesh$triangles - 1
storage.mode(mesh$triangles) <- "integer"
storage.mode(mesh$nodes) <- "double"
if(mesh$order==1){
outCPP <- .Call("CPP_TriangleMeshSplit", mesh$triangles[,1:3], mesh$nodes)
splittedmesh<-create.mesh.2D(nodes=rbind(mesh$nodes, outCPP[[2]]), triangles=outCPP[[1]])
}
else if(mesh$order==2){
outCPP <- .Call("CPP_TriangleMeshSplitOrder2", mesh$triangles[,1:3], mesh$nodes)
splittedmesh<-create.mesh.2D(nodes=mesh$nodes, triangles=outCPP[[1]], order=2)
}
return(splittedmesh)
}
load("~/Desktop/PACS/Progetto/pacsColliColombo/data/square2Ddata.RData")
mesh=create.mesh.2D(nodes=nodes)
for(i in 1:1){
mesh<-split.mesh.2D(mesh)
}
# x11()
# axis(1)
# axis(2)
nnodes=dim(mesh$nodes)[1]
FEMbasis=create.FEM.basis(mesh)
# Test function
set.seed(5847947)
a1=runif(1,min=-1.5,max=1.5)
a2=runif(1,min=-1.5,max=1.5)
z<-function(p)
{
a1*sin(2*pi*p[1])*cos(2*pi*p[2])+a2*sin(3*pi*p[1])
}
# Exact solution (pointwise at nodes)
sol_exact=rep(0,dim(mesh$nodes)[1])
for(i in 1: dim(mesh$nodes)[1])
sol_exact[i]=z(mesh$nodes[i,])
ran=range(sol_exact)
# Set smoothing parameter
lambda= 10^-3
GCVFLAG=T
GCVMETHODFLAG='Exact'
data = sol_exact + rnorm(nnodes, mean=0, sd=0.05*(ran[2]-ran[1]))
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda,
GCV=GCVFLAG, GCVmethod = GCVMETHODFLAG,search="naive")
output_tree<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda,
GCV=GCVFLAG, GCVmethod = GCVMETHODFLAG)
N<-50
mytimenaive<-vector(mode="numeric", N)
mytimetree<-vector(mode="numeric", N)
mytimenewtree<-vector(mode="numeric", N)
mytimewalk<-vector(mode="numeric", N)
nloc = 100
treetimes<-NULL
newtreetimes<-NULL
walktimes<-NULL
naivetimes<-NULL
for(j in 1:10){
# Generate locations
loc=matrix(data=runif(2*nloc, min=min(nodes),max=max(nodes)),nrow=nloc,ncol=2,byrow=T)
nloc = 2*nloc
for(i in 1:N){
mytimenaive[i]<-system.time(eval.FEM(output_CPP$fit.FEM,locations=loc, search="naive"))["elapsed"]
mytimewalk[i]<-system.time(eval.FEM(output_CPP$fit.FEM,locations=loc, search="walking"))["elapsed"]
mytimetree[i]<-system.time(eval.FEM(output_tree$fit.FEM,locations=loc, search="tree"))["elapsed"]
mytimenewtree[i]<-system.time(eval.FEM(output_CPP$fit.FEM,locations=loc, search="tree"))["elapsed"]
}
treetimes<-cbind(treetimes, mytimetree)
newtreetimes<-cbind(newtreetimes, mytimenewtree)
walktimes<-cbind(walktimes, mytimewalk)
naivetimes<-cbind(naivetimes, mytimenaive)
}
rm(list=setdiff(ls(), c("mesh","naivetimes","treetimes","newtreetimes","walktimes")))
detach("package:fdaPDE", unload = TRUE)
library(currentfdaPDE)
load("~/Desktop/PACS/Progetto/pacsColliColombo/data/square2Ddata.RData")
mesh=create.mesh.2D(nodes=mesh$nodes, triangle=mesh$triangles)
# x11()
# axis(1)
# axis(2)
nnodes=dim(mesh$nodes)[1]
FEMbasis=create.FEM.basis(mesh)
# Test function
set.seed(5847947)
a1=runif(1,min=-1.5,max=1.5)
a2=runif(1,min=-1.5,max=1.5)
z<-function(p)
{
a1*sin(2*pi*p[1])*cos(2*pi*p[2])+a2*sin(3*pi*p[1])
}
# Exact solution (pointwise at nodes)
sol_exact=rep(0,dim(mesh$nodes)[1])
for(i in 1: dim(mesh$nodes)[1])
sol_exact[i]=z(mesh$nodes[i,])
ran=range(sol_exact)
# Set smoothing parameter
lambda= 10^-3
GCVFLAG=T
GCVMETHODFLAG='Exact'
data = sol_exact + rnorm(nnodes, mean=0, sd=0.05*(ran[2]-ran[1]))
output_CPP<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda,
GCV=GCVFLAG, GCVmethod = GCVMETHODFLAG,search="naive")
output_tree<-smooth.FEM(observations=data, FEMbasis=FEMbasis, lambda=lambda,
GCV=GCVFLAG, GCVmethod = GCVMETHODFLAG)
output_CPP$fit.FEM$FEMbasis<-FEMbasis
N<-50
mytimenaiveold<-vector(mode="numeric", N)
mytimewalkold<-vector(mode="numeric", N)
mytimetreeold<-vector(mode="numeric", N)
mytimenewtreeold<-vector(mode="numeric", N)
nloc = 100
treetimesold<-NULL
newtreetimesold<-NULL
walktimesold<-NULL
naivetimesold<-NULL
for(j in 1:10){
loc=matrix(data=runif(2*nloc, min=min(nodes),max=max(nodes)),nrow=nloc,ncol=2,byrow=T)
nloc = 2*nloc
for(i in 1:N){
mytimenaiveold[i]<-system.time(eval.FEM(output_CPP$fit.FEM,locations=loc, search="naive"))["elapsed"]
mytimewalkold[i]<-system.time(eval.FEM(output_CPP$fit.FEM,locations=loc, search="walking"))["elapsed"]
mytimetreeold[i]<-system.time(eval.FEM(output_tree$fit.FEM,locations=loc, search="tree"))["elapsed"]
mytimenewtreeold[i]<-system.time(eval.FEM(output_CPP$fit.FEM,locations=loc, search="tree"))["elapsed"]
}
treetimesold<-cbind(treetimesold, mytimetreeold)
newtreetimesold<-cbind(newtreetimesold, mytimenewtreeold)
walktimesold<-cbind(walktimesold, mytimewalkold)
naivetimesold<-cbind(naivetimesold, mytimenaiveold)
}
xvals<-log10(100*2^(0:9))
names(xvals)<-c("100","200","400","800","1600","3200","6400","12800","25600","51200")
plot(xvals, log10(apply(walktimes,2,median)),
ylim=range(log10(apply(walktimes,2,median)), log10(apply(naivetimesold,2,median))),
type="l", col="black",xaxt = "n",xlab="#points to search", ylab="median time")
axis(1, at=xvals, labels=names(xvals))
lines(xvals, log10(apply(treetimes,2,median)), col="red")
lines(xvals, log10(apply(newtreetimes,2,median)), col="blue")
lines(xvals, log10(apply(treetimesold,2,median)), col="green")
lines(xvals, log10(apply(newtreetimesold,2,median)), col="orange")
lines(xvals, log10(apply(walktimesold,2,median)), col="gray")
lines(xvals, log10(apply(naivetimesold,2,median)), col="purple")
lines(xvals, log10(apply(naivetimes,2,median)), col="yellow")
legend("bottomright", legend=c("walk", "tree","tree0","old_tree","old_tree0", "old_walk","naive","old_naive"),
fill=c("black", "red","blue","green","orange", "gray", "yellow", "purple"),cex=0.8)
# log10(apply(naivetimes,2,median))-log10(apply(naivetimesold,2,median))
xvals<-log10(100*2^(0:9))
names(xvals)<-c("100","200","400","800","1600","3200","6400","12800","25600","51200")
plot(xvals, log10(apply(walktimes,2,median)),
ylim=range(log10(apply(walktimes,2,median)), log10(apply(naivetimesold,2,median))),
type="l", col="black",xaxt = "n",xlab="#points to search", ylab="median time")
axis(1, at=xvals, labels=names(xvals))
lines(xvals, log10(apply(treetimes,2,median)), col="red")
lines(xvals, log10(apply(newtreetimes,2,median)), col="blue")
lines(xvals, log10(apply(treetimesold,2,median)), col="green")
lines(xvals, log10(apply(newtreetimesold,2,median)), col="orange")
lines(xvals, log10(apply(walktimesold,2,median)), col="gray")
lines(xvals, log10(apply(naivetimesold,2,median)), col="purple")
lines(xvals, log10(apply(naivetimes,2,median)), col="yellow")
legend("bottomright", legend=c("walk", "tree","tree0","old_tree","old_tree0", "old_walk","naive","old_naive"),
fill=c("black", "red","blue","green","orange", "gray", "yellow", "purple"),cex=0.8)
log10(apply(naivetimes,2,median))-log10(apply(naivetimesold,2,median))
log10(apply(naivetimes,2,median))-log10(apply(naivetimesold,2,median))
log10(apply(walktimes,2,median))-log10(apply(walktimesold,2,median))
library(fdaPDE)
rm(list=ls())
load("~/Desktop/PACS/Progetto/pacsColliColombo/data/hub25Ddata.RData")
mesh <- create.mesh.2.5D(nodes = nodes,triangles = triangles)
mesh$nodesmarkers
mesh <- create.mesh.2.5D(nodes = nodes,triangles = triangles,order=2)
library(fdaPDE)
load("~/Desktop/PACS/Progetto/pacsColliColombo/data/square2Ddata.RData")
mesh=create.mesh.2D(nodes=nodes)
mesh=create.mesh.2D(nodes=nodes,order=2)
rm(list=ls())
load("~/Desktop/PACS/Progetto/pacsColliColombo/data/hub25Ddata.RData")
mesh <- create.mesh.2.5D(nodes = nodes,triangles = triangles)
mesh <- create.mesh.2.5D(nodes = nodes,triangles = triangles,order=2)
plot(mesh)
plot.mesh.2.5D<-function(x,...){
nodes <- x$nodes
edges <- as.vector(t(x$edges))
open3d()
axes3d()
rgl.pop("lights")
light3d(specular="black")
rgl.points(nodes[,1], nodes[,2], nodes[,3], col="black", ...)
rgl.lines(nodes[edges,1], nodes[edges,2], nodes[edges,3], col="black",...)
aspect3d("iso")
rgl.viewpoint(0,-45)
}
plot.mesh.2.5D(mesh)
mesh <- create.mesh.2.5D(nodes = nodes,triangles = triangles)
plot.mesh.2.5D(mesh)
rgl.lines(mesh$nodes[as.vector(t(mesh$edges),1],mesh$nodes[as.vector(t(mesh$edges),2],mesh$nodes[as.vector(t(mesh$edges),3])
rgl.lines(mesh$nodes[as.vector(t(mesh$edges),1],mesh$nodes[as.vector(t(mesh$edges),2],mesh$nodes[as.vector(t(mesh$edges),3])
rgl.lines(mesh$nodes[as.vector(t(mesh$edges)),1],mesh$nodes[as.vector(t(mesh$edges)),2],mesh$nodes[as.vector(t(mesh$edges)),3])
mesh$nodes[as.vector(t(mesh$edges)),3]
length(mesh$nodes[as.vector(t(mesh$edges)),3])
length(mesh$nodes[as.vector(t(mesh$edges)),1])
length(mesh$nodes[as.vector(t(mesh$edges)),2])
3%%2
4%%2
dim(mesh$edges)
prod(dim(mesh$edges))
edges<-as.vector(t(mesh$edges))
min(mesh$triangles)
min(mesh$edges)
min(mesh$neighbors)
max(mesh$triangles)
mesh <- create.mesh.2.5D(nodes = nodes,triangles = triangles,order=2)
max(mesh$triangles)
library(fdaPDE)
rm(list=ls())
load("~/Desktop/PACS/Progetto/pacsColliColombo/data/hub25Ddata.RData")
mesh <- create.mesh.2.5D(nodes = nodes,triangles = triangles)
plot(mesh)
mesh <- create.mesh.2.5D(nodes = nodes,triangles = triangles,order=2)
plot(mesh)
rgl.points(nodes[,1], nodes[,2], nodes[,3], col="black", ...)
rgl.points(mesh$nodes[,1], mesh$nodes[,2], mesh$nodes[,3], col="black")
rgl.points(mesh$nodes[,1], mesh$nodes[,2], mesh$nodes[,3], col="black")
range(mesh$neighbors)
range(mesh$triangles)
library(fdaPDE)
rm(list=ls())
load("~/Desktop/PACS/Progetto/pacsColliColombo/data/hub25Ddata.RData")
mesh <- create.mesh.2.5D(nodes = nodes,triangles = triangles)
plot(mesh)
mesh <- create.mesh.2.5D(nodes = nodes,triangles = triangles,order=2)
plot(mesh)ù
plot(mesh)
setwd("~/Desktop/PACS/Progetto/fdaPDE")
library(roxygen2)
roxygenise()
roxygenise()
roxygenise()
