response # binomial samples (true or false)
sol_exact # true field (function z with coefficient a1 a2) valutated over the locations
param # \theta(beta, sol_exact) in this example beta = NULL
# Plotting the Simulation Settings -----
# mesh
{
plot(mesh, lwd=1.5, cex = 0.4)
}
# mesh with points
{
plot(mesh, lwd=1, cex = 0.4)
par(new=TRUE)
plot(loc, pch = 19 , cex = 0.8, col = "#101875")
}
# true field
{
xvec = seq(0,1,by = 0.01)
yvec = seq(0,1,by = 0.01)
xy = cbind(xvec,yvec)
s = sort(xvec, index.return = TRUE)
xvec = unique(xvec[s$ix])
s = sort(yvec, index.return = TRUE)
yvec = unique(yvec[s$ix])
z_mat = matrix(ncol = length(yvec), nrow = length(xvec))
for(i in 1:length(xvec)){
for(j in 1:length(yvec)){
z_mat[i,j] <- z(c(xvec[i],yvec[j]))
}
}
image(xvec,yvec,z_mat,col=heat.colors(100),xlab="x",ylab="y")
contour(xvec,yvec,z_mat,add=TRUE)
}
# sampled data
{
plot(mesh, lwd=1, cex = 0.5)
par(new=TRUE)
plot(loc[response,], pch = 1 , cex = 1, col = "#0AA398") # TRUE (1)
par(new=TRUE)
plot(loc[!response,], pch = 4, cex = 1, col = "#E5401D" , xaxt = 'n', yaxt = 'n', ann=FALSE) # FALSE (0)
}
# mu (no covariates)
{
xvec = seq(0,1,by = 0.01)
yvec = seq(0,1,by = 0.01)
xy = cbind(xvec,yvec)
s = sort(xvec, index.return = TRUE)
xvec = unique(xvec[s$ix])
s = sort(yvec, index.return = TRUE)
yvec = unique(yvec[s$ix])
z_mat = matrix(ncol = length(yvec), nrow = length(xvec))
for(i in 1:length(xvec)){
for(j in 1:length(yvec)){
z_mat[i,j] <- inv.link(z(c(xvec[i],yvec[j])))
}
}
image(xvec,yvec,z_mat,col=heat.colors(100),xlab="x",ylab="y")
contour(xvec,yvec,z_mat,add=TRUE)
}
# Fitting solution --------
FAMILY = "binomial"
lambda = 10^seq(-5,0,length.out = 20)
output_CPP_exact <- fdaPDE::smooth.FEM(location = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = NULL, GCV=T, GCVmethod = "Exact",
lambda = lambda, max.steps=15, fam=FAMILY, mu0=NULL, scale.param=NULL)
output_CPP_stoch <- fdaPDE::smooth.FEM(location = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = NULL, GCV=T, GCVmethod = "Stochastic",
lambda = lambda, max.steps=15, fam=FAMILY, mu0=NULL, scale.param=NULL)
#.rs.restartR()
rm(list=ls())
rm(list=ls())
graphics.off()
library(fdaPDE)
library(purrr)
library(pracma)
library(ggplot2)
FAMILY = "poisson"
l<-make.link("log")
link<-l$linkfun
inv.link<-l$linkinv
beta1= 5
lambda = 10^seq(-8,3,length.out = 20)
GCVFLAG=T
GCVmethod='Exact'
scale.param = 1
data(AREAL_MeshC)
nodes = mesh$nodes
# x11()
plot(mesh, lwd=3, cex = 1.9)
nnodes = dim(mesh$nodes)[1]
FEMbasis = fdaPDE::create.FEM.basis(mesh)
# 2D random field (function f) ------------------------------
a_fun <- function(p){
if(p[1]>= 0 && p[2] > 0){
pi/4 + p[1]
}else{
if(p[1]>= 0 && p[2] <= 0){
-pi/4 -p[1]
}else{
if(p[1] < 0){
-0.5*atan(p[2]/p[1])
}
}
}
}
d_fun <- function(p){
if(p[1]>= 0 && p[2] > 0){
-0.5 + p[2]
}else{
if(p[1]>= 0 && p[2] <= 0){
-0.5 - p[2]
}else{
if(p[1] < 0){
sqrt(p[1]^2 + p[2]^2) - 0.5
}
}
}
}
z <- function(p){
a_fun(p) + d_fun(p)^2
}
tri = mesh$triangles
dim(incidence_matrix)
dim(tri)
integration_nodes = data.frame(matrix(nrow = dim(incidence_matrix)[2],ncol = 11))
names(integration_nodes) = c("T1","T2","N1","N2","N3","N4", "xmin", "xmax", "ymin", "ymax", "label")
nodi_plot = NULL
for(i in 1:dim(incidence_matrix)[2]){
tri_used = which(incidence_matrix[,i] == 1)
integration_nodes$T1[i] = tri_used[1]
integration_nodes$T2[i] = tri_used[2]
nodes_used = unique(c(tri[tri_used[1],],tri[tri_used[2],]))
integration_nodes$N1[i] = nodes_used[1]
integration_nodes$N2[i] = nodes_used[2]
integration_nodes$N3[i] = nodes_used[3]
integration_nodes$N4[i] = nodes_used[4]
integration_nodes$label[i] = i
xvec = c(nodes[integration_nodes$N1[i],1],nodes[integration_nodes$N2[i],1],nodes[integration_nodes$N3[i],1],nodes[integration_nodes$N4[i],1])
yvec = c(nodes[integration_nodes$N1[i],2],nodes[integration_nodes$N2[i],2],nodes[integration_nodes$N3[i],2],nodes[integration_nodes$N4[i],2])
integration_nodes$xmin[i] = min(xvec)
integration_nodes$xmax[i] = max(xvec)
integration_nodes$ymin[i] = min(yvec)
integration_nodes$ymax[i] = max(yvec)
nodi_tmp = rbind(mesh$nodes[integration_nodes$N1[i],],mesh$nodes[integration_nodes$N2[i],],mesh$nodes[integration_nodes$N3[i],],mesh$nodes[integration_nodes$N4[i],])
nodi_tmp = cbind(nodi_tmp,rep(i,4))
nodi_plot = rbind(nodi_plot,nodi_tmp)
}
nodi_plot <- as.data.frame(nodi_plot)
names(nodi_plot) = c("X","Y","Tri")
nodi_plot$Tri = as.factor(nodi_plot$Tri)
nnodes = dim(mesh$nodes)[1]
plot_values = numeric(nnodes)
for(i in 1:dim(incidence_matrix)[2]){
plot_values[integration_nodes$N1[i]] = 15
plot_values[integration_nodes$N2[i]] = 15
plot_values[integration_nodes$N3[i]] = 15
plot_values[integration_nodes$N4[i]] = 15
}
image(FEM(plot_values,FEMbasis))
# ---------------------------------------------------------------
nnodes = dim(mesh$nodes)[1]
sol_exact <- numeric(nnodes)
for(i in 1:nnodes){
sol_exact[i] <- z(mesh$nodes[i,])
}
z_xy <- function(x,y){z(c(x,y))}
sol_integrand = matrix(nrow = 20 , ncol = 1)
for(i in 1:20){
res = integral2(fun = z_xy, xmin = integration_nodes$xmin[i], xmax = integration_nodes$xmax[i] , ymin = integration_nodes$ymin[i], ymax = integration_nodes$ymax[i])
sol_integrand[i] = res$Q
}
range(sol_integrand)
set.seed(2020)
# covariates ---------------------------
desmat=matrix(0,nrow=length(sol_integrand),ncol=1)
desmat[,1]=rbeta(length(sol_integrand),shape1=2,shape2=2)  # sampling covariates from beta distr.
theta = sol_integrand + desmat%*%beta1
range(theta)
mu = inv.link(theta)
range(mu)
# sampling response:
response <- rpois(length(mu), lambda = mu)
output_CPP <- fdaPDE::smooth.FEM(observations = as.numeric(response), FEMbasis =FEMbasis, covariates = desmat, GCV=GCVFLAG, GCVmethod = GCVmethod,
lambda = lambda, max.steps=15, fam=FAMILY, mu0=NULL, scale.param=NULL, incidence_matrix = t(incidence_matrix), areal.data.avg = FALSE)
# BINOMIAL 2D SQUARE SIMULATION
# see section 5.2.1 on report for the theoretical setting
rm(list=ls())
graphics.off()
# LOAD library ----------------------------------------
library(fdaPDE)
library(purrr)
# LOAD data ----------------------------------------
data("BINOMIAL_SQUARE_2D")
# Description of binomial data variables -------
mesh # 2D Square mesh
loc # points over the mesh
nloc # total number of points over the mesh
mu # mean parameter
response # binomial samples (true or false)
sol_exact # true field (function z with coefficient a1 a2) valutated over the locations
param # \theta(beta, sol_exact) in this example beta = NULL
# Plotting the Simulation Settings -----
# mesh
{
plot(mesh, lwd=1.5, cex = 0.4)
}
# mesh with points
{
plot(mesh, lwd=1, cex = 0.4)
par(new=TRUE)
plot(loc, pch = 19 , cex = 0.8, col = "#101875")
}
# true field
{
xvec = seq(0,1,by = 0.01)
yvec = seq(0,1,by = 0.01)
xy = cbind(xvec,yvec)
s = sort(xvec, index.return = TRUE)
xvec = unique(xvec[s$ix])
s = sort(yvec, index.return = TRUE)
yvec = unique(yvec[s$ix])
z_mat = matrix(ncol = length(yvec), nrow = length(xvec))
for(i in 1:length(xvec)){
for(j in 1:length(yvec)){
z_mat[i,j] <- z(c(xvec[i],yvec[j]))
}
}
image(xvec,yvec,z_mat,col=heat.colors(100),xlab="x",ylab="y")
contour(xvec,yvec,z_mat,add=TRUE)
}
# sampled data
{
plot(mesh, lwd=1, cex = 0.5)
par(new=TRUE)
plot(loc[response,], pch = 1 , cex = 1, col = "#0AA398") # TRUE (1)
par(new=TRUE)
plot(loc[!response,], pch = 4, cex = 1, col = "#E5401D" , xaxt = 'n', yaxt = 'n', ann=FALSE) # FALSE (0)
}
# mu (no covariates)
{
xvec = seq(0,1,by = 0.01)
yvec = seq(0,1,by = 0.01)
xy = cbind(xvec,yvec)
s = sort(xvec, index.return = TRUE)
xvec = unique(xvec[s$ix])
s = sort(yvec, index.return = TRUE)
yvec = unique(yvec[s$ix])
z_mat = matrix(ncol = length(yvec), nrow = length(xvec))
for(i in 1:length(xvec)){
for(j in 1:length(yvec)){
z_mat[i,j] <- inv.link(z(c(xvec[i],yvec[j])))
}
}
image(xvec,yvec,z_mat,col=heat.colors(100),xlab="x",ylab="y")
contour(xvec,yvec,z_mat,add=TRUE)
}
# Fitting solution --------
FAMILY = "gamma"
lambda = 10^seq(-5,0,length.out = 20)
output_CPP_exact <- fdaPDE::smooth.FEM(location = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = NULL, GCV=T, GCVmethod = "Exact",
lambda = lambda, max.steps=15, fam=FAMILY, mu0=NULL, scale.param=NULL)
# TESTS FOR MESH C 2D AREAL DATA
rm(list=ls())
graphics.off()
# LOAD library --------------------------------------
library(fdaPDE)
library(purrr)
library(pracma)
library(ggplot2)
# FAMILY CHOICE ----------------------------------------
FAMILY = "poisson"
l<-make.link("log")
link<-l$linkfun
inv.link<-l$linkinv
# BETA ------------------------------------------------
beta1= 5
# lambda ---------------------------------------------
lambda = 10^seq(-8,3,length.out = 20)
GCVFLAG=T
GCVmethod='Exact'
# scale param -----------------------------------------
scale.param = 1
# -------------------- CODE ---------------------------
data(AREAL_MeshC)
nodes = mesh$nodes
# x11()
plot(mesh, lwd=3, cex = 1.9)
nnodes = dim(mesh$nodes)[1]
FEMbasis = fdaPDE::create.FEM.basis(mesh)
# 2D random field (function f) ------------------------------
a_fun <- function(p){
if(p[1]>= 0 && p[2] > 0){
pi/4 + p[1]
}else{
if(p[1]>= 0 && p[2] <= 0){
-pi/4 -p[1]
}else{
if(p[1] < 0){
-0.5*atan(p[2]/p[1])
}
}
}
}
d_fun <- function(p){
if(p[1]>= 0 && p[2] > 0){
-0.5 + p[2]
}else{
if(p[1]>= 0 && p[2] <= 0){
-0.5 - p[2]
}else{
if(p[1] < 0){
sqrt(p[1]^2 + p[2]^2) - 0.5
}
}
}
}
z <- function(p){
a_fun(p) + d_fun(p)^2
}
tri = mesh$triangles
dim(incidence_matrix)
dim(tri)
integration_nodes = data.frame(matrix(nrow = dim(incidence_matrix)[2],ncol = 11))
names(integration_nodes) = c("T1","T2","N1","N2","N3","N4", "xmin", "xmax", "ymin", "ymax", "label")
nodi_plot = NULL
for(i in 1:dim(incidence_matrix)[2]){
tri_used = which(incidence_matrix[,i] == 1)
integration_nodes$T1[i] = tri_used[1]
integration_nodes$T2[i] = tri_used[2]
nodes_used = unique(c(tri[tri_used[1],],tri[tri_used[2],]))
integration_nodes$N1[i] = nodes_used[1]
integration_nodes$N2[i] = nodes_used[2]
integration_nodes$N3[i] = nodes_used[3]
integration_nodes$N4[i] = nodes_used[4]
integration_nodes$label[i] = i
xvec = c(nodes[integration_nodes$N1[i],1],nodes[integration_nodes$N2[i],1],nodes[integration_nodes$N3[i],1],nodes[integration_nodes$N4[i],1])
yvec = c(nodes[integration_nodes$N1[i],2],nodes[integration_nodes$N2[i],2],nodes[integration_nodes$N3[i],2],nodes[integration_nodes$N4[i],2])
integration_nodes$xmin[i] = min(xvec)
integration_nodes$xmax[i] = max(xvec)
integration_nodes$ymin[i] = min(yvec)
integration_nodes$ymax[i] = max(yvec)
nodi_tmp = rbind(mesh$nodes[integration_nodes$N1[i],],mesh$nodes[integration_nodes$N2[i],],mesh$nodes[integration_nodes$N3[i],],mesh$nodes[integration_nodes$N4[i],])
nodi_tmp = cbind(nodi_tmp,rep(i,4))
nodi_plot = rbind(nodi_plot,nodi_tmp)
}
nodi_plot <- as.data.frame(nodi_plot)
names(nodi_plot) = c("X","Y","Tri")
nodi_plot$Tri = as.factor(nodi_plot$Tri)
# plot mesh areale ---------------------------------------------
nnodes = dim(mesh$nodes)[1]
plot_values = numeric(nnodes)
for(i in 1:dim(incidence_matrix)[2]){
plot_values[integration_nodes$N1[i]] = 15
plot_values[integration_nodes$N2[i]] = 15
plot_values[integration_nodes$N3[i]] = 15
plot_values[integration_nodes$N4[i]] = 15
}
image(FEM(plot_values,FEMbasis))
# ---------------------------------------------------------------
nnodes = dim(mesh$nodes)[1]
sol_exact <- numeric(nnodes)
for(i in 1:nnodes){
sol_exact[i] <- z(mesh$nodes[i,])
}
z_xy <- function(x,y){z(c(x,y))}
sol_integrand = matrix(nrow = 20 , ncol = 1)
for(i in 1:20){
res = integral2(fun = z_xy, xmin = integration_nodes$xmin[i], xmax = integration_nodes$xmax[i] , ymin = integration_nodes$ymin[i], ymax = integration_nodes$ymax[i])
sol_integrand[i] = res$Q
}
range(sol_integrand)
set.seed(2020)
# covariates ---------------------------
desmat=matrix(0,nrow=length(sol_integrand),ncol=1)
desmat[,1]=rbeta(length(sol_integrand),shape1=2,shape2=2)  # sampling covariates from beta distr.
theta = sol_integrand + desmat%*%beta1
range(theta)
mu = inv.link(theta)
range(mu)
# sampling response:
response <- rpois(length(mu), lambda = mu)
#.rs.restartR()
rm(list=ls())
graphics.off()
library(fdaPDE)
library(purrr)
FAMILY = "gamma"
link<-function(x){-1/x}
inv.link<-link
beta1=0.8
beta2=1.2
beta_exact=c(beta1,beta2)
lambda = 10^seq(-1,3,length.out = 10)
GCVFLAG=T
GCVmethod = 'Stochastic'
GCVmethod = 'Exact'
scale.param = 1
# mesh reading:
data("sphere3Ddata")
sphere3D<-create.mesh.3D(sphere3Ddata$nodes, sphere3Ddata$tetrahedrons)
#plot(sphere3D)
FEMbasis <- fdaPDE::create.FEM.basis(sphere3D)
nodesLocations=sphere3D$nodes
set.seed(5847947)
set.seed(42)
new_grid3d = cbind(runif(1000,min = -1 , max = 1),runif(1000,min = -1 , max = 1),runif(1000,min = -1 , max = 1))
for(i in 1:length(new_grid3d[,1])){
if(new_grid3d[i,1]^2 + new_grid3d[i,2]^2 + new_grid3d[i,3]^2 >= 0.98){
new_grid3d[i,] <- c(NA,NA,NA)
}
}
new_loc <- matrix(ncol = 3, nrow = sum(!is.na(new_grid3d[,1])))
new_loc[,1] <- new_grid3d[!is.na(new_grid3d[,1]),1]
new_loc[,2] <- new_grid3d[!is.na(new_grid3d[,1]),2]
new_loc[,3] <- new_grid3d[!is.na(new_grid3d[,1]),3]
loc <- rbind(nodesLocations, new_loc)
dim(loc)
# Exact test function - locations at nodes
nnodes = sphere3D$nnodes
nloc = dim(loc)[1]
a1 = rnorm(1,mean = -2, sd = 1/8)
a2 = rnorm(1,mean = -2, sd = 1/8)
a3 = rnorm(1,mean = -2, sd = 1/8)
a1 = -1
a2 = -2
a3 = -3
func_evaluation = numeric(nloc)
for (i in 0:(nloc-1)){
func_evaluation[i+1] = a1* sin(loc[i+1,1]) +  a2* sin(loc[i+1,2]) +  a3*sin(loc[i+1,3]) - 7
}
ran=range(func_evaluation)
ran
cov1_nonod=sin(2*pi*loc[,1])+sin((2*pi*loc[,2])^2)
cov2_nonod=cos(-2*pi*loc[,3])
plot(FEM(cov1_nonod[1:nnodes], FEMbasis))
plot(FEM(cov2_nonod[1:nnodes], FEMbasis))
W2=cbind(cov1_nonod,cov2_nonod)
# Evaluation on a planar cut
{
grid_planar_ = cbind(runif(1000,min = -1 , max = 1),runif(1000,min = -1 , max = 1))
radius = 1
for(i in 1:length(grid_planar_[,1])){
if(grid_planar_[i,1]^2+grid_planar_[i,2]^2 >= radius){
grid_planar_[i,] <- c(NA,NA)
}
}
grid_planar <- matrix(ncol=2, nrow = sum(!is.na(grid_planar_[,1])))
grid_planar[,1] <- grid_planar_[!is.na(grid_planar_[,1]),1]
grid_planar[,2] <- grid_planar_[!is.na(grid_planar_[,2]),2]
cov1_planar=sin(2*pi*grid_planar[,1])+sin((2*pi*grid_planar[,2])^2)
meshgrid2d <- create.mesh.2D(nodes=grid_planar)
plot(meshgrid2d)
FEM_basis_planar = fdaPDE::create.FEM.basis(meshgrid2d)
image(FEM(cov1_planar, FEM_basis_planar))
}
range(W2%*%beta_exact + func_evaluation)
theta = func_evaluation + W2%*%beta_exact
plot(FEM(theta[1:nnodes], FEMbasis))
mu = inv.link(theta)
plot(FEM(mu[1:nnodes], FEMbasis))
range(mu)
response <- rgamma(length(loc[,1]), shape=mu/scale.param, scale=scale.param)
plot(FEM(response[1:nnodes],FEMbasis))
output_CPP <- fdaPDE::smooth.FEM(locations = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = W2, GCV=GCVFLAG, GCVmethod = GCVmethod,
lambda = lambda, max.steps=15, fam=FAMILY, mu0=NULL, scale.param=NULL,tune=1)
func_estimation = output_CPP$fit.FEM$coeff[,output_CPP$bestlambda]
plot(FEM(func_evaluation[1:nnodes],FEMbasis))
#.rs.restartR()
rm(list=ls())
#.rs.restartR()
rm(list=ls())
graphics.off()
# LOAD library ----------------------------------------
library(fdaPDE)
library(purrr)
FAMILY = "poisson"
l<-make.link("log")
link<-l$linkfun
inv.link<-l$linkinv
beta1= 2
beta2= -3
betas_truth = c(beta1,beta2)
lambda = c(0.0001,0.001,0.005,0.006,0.007,0.008,0.009,0.0095, 0.00975,0.01,0.0125,0.015,0.02,0.03,0.04,0.05,0.1,1,10,100,1000)
GCVFLAG=T
scale.param = 1
# mesh reading: -----------------------------------------------
data(hub25Ddata)
mesh <- create.mesh.2.5D(nodes = nodes,triangles = triangles)
FEMbasis <- create.FEM.basis(mesh)
# locations -----------------------------------------------
loc=mesh$nodes
nloc = dim(loc)[1]
# 2.5D random field (function f) ------------------------------
a1 = rnorm(1,mean = 0, sd = 1)
a2 = rnorm(1,mean = 0, sd = 1)
a3 = rnorm(1,mean = 0, sd = 1)
sol_exact = numeric(nloc)
for (i in 0:(nloc-1)){
sol_exact[i+1] = a1* sin(2*pi*loc[i+1,1]) +  a2* sin(2*pi*loc[i+1,2]) +  a3*sin(2*pi*loc[i+1,3]) + 7
}
range(sol_exact)
# covariates ---------------------------------------------------------
set.seed(42)
desmat=matrix(0,nrow=nloc, ncol=2)
desmat[,1]= sin(2*pi*loc[,1])*cos(2*pi*loc[,2])
desmat[,2]= rnorm(nloc, mean=2, sd=0.1)
# samoploing response: --------------------------------------------------
ran=range(desmat%*%betas_truth + sol_exact)
param=sol_exact+beta1*desmat[,1]+beta2*desmat[,2]
mu<-inv.link(param)
range(mu)
response <- rpois(nloc, lambda = mu)
# Fitting --------------------------------------------------------
output_CPP_exact<- smooth.FEM(location = NULL, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = desmat, GCV=GCVFLAG, GCVmethod = "Exact",
lambda = lambda, max.steps=15, fam=FAMILY, mu0=NULL, scale.param=NULL)
