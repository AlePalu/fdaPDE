plot(log10(lambda),output_CPP$optimization$GCV_vector)
image(FEM(output_CPP$fit.FEM$coeff[,output_CPP$lambda_position],FEMbasis))
image(FEM(output_CPP$fit.FEM$coeff[,output_CPP$optimization$lambda_position],FEMbasis))
image(FEM(sol_nodes, FEMbasis))
###############################################
############## TEST SCRIPT GAM  ###############
###############################################
rm(list=ls())
graphics.off()
library(fdaPDE)
#### Test 1: square domain BINOMIAL family ####
#            locations = nodes
#            laplacian
#            no covariates
#            no BC
#            order FE = 1
#
library(fdaPDE)
FAMILY = "binomial"
library(purrr)
logit <- function(x){qlogis(x)}
inv.logit <- function(x){plogis(x)}
link = logit
inv.link = inv.logit
# mesh
x = seq(0,1, length.out = 40)
y = x
locations = expand.grid(x,y)
mesh = create.mesh.2D(locations)
plot(mesh)
nnodes = dim(mesh$nodes)[1]
FEMbasis = create.FEM.basis(mesh)
set.seed(42)
# locations
nloc = 800
xobs=runif(min=0,max=1,n=nloc)
yobs=runif(min=0,max=1,n=nloc)
loc=cbind(xobs,yobs)
# 2D random field (function f)
a1=-2.5
a2=0.8
z<-function(p)
{
a1*sin(2*pi*p[1])*cos(2*pi*p[2])+a2*sin(3*pi*p[1])
}
# exact solution
sol_exact=rep(0,length(loc[,1]))
for(i in 1:length(loc[,1])){
sol_exact[i] <- z(loc[i,])
}
nnodes = dim(mesh$nodes)[1]
sol_nodes = numeric(nnodes)
for(i in 1:nnodes){
sol_nodes[i] = z(mesh$nodes[i,])
}
range(sol_exact)
param = sol_exact
mu<-inv.link(param)
range(mu)
# sampling response:
response <- rbernoulli(length(loc[,1]),p = mu)
# Set smoothing parameter
lambda = 10^seq(-5,0,length.out = 20)
#### Test 1.2: With exact GCV
output_CPP <- fdaPDE::smooth.FEM(location = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = NULL,
max.steps=15, fam=FAMILY, mu0=NULL, scale.param=NULL,
lambda = lambda, lambda.selection.criterion = 'grid', DOF.evaluation = 'exact', lambda.selection.lossfunction = 'GCV')
plot(log10(lambda),output_CPP$optimization$GCV_vector)
image(FEM(output_CPP$fit.FEM$coeff[,output_CPP$optimization$lambda_position],FEMbasis))
image(FEM(sol_nodes, FEMbasis))
#### Test 1.3: With stochastic GCV
output_CPP <- fdaPDE::smooth.FEM(location = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = NULL,
max.steps=15, fam=FAMILY, mu0=NULL, scale.param=NULL,
lambda = lambda, lambda.selection.criterion = 'grid', DOF.evaluation = 'stochastic', lambda.selection.lossfunction = 'GCV')
plot(log10(lambda),output_CPP$optimization$GCV_vector)
image(FEM(output_CPP$fit.FEM$coeff[,output_CPP$optimization$lambda_position],FEMbasis))
image(FEM(sol_nodes, FEMbasis))
#### Test 2: square domain EXPONENTIAL family ####
#            locations = nodes
#            laplacian
#            no covariates
#            no BC
#            order FE = 1
#
library(fdaPDE)
rm(list=ls())
graphics.off()
FAMILY = "exponential"
link<-function(x){-1/x}
inv.link<-link
# mesh
x = seq(0,1, length.out = 40)
y = x
locations = expand.grid(x,y)
mesh = create.mesh.2D(locations)
plot(mesh)
nnodes = dim(mesh$nodes)[1]
FEMbasis = create.FEM.basis(mesh)
# locations -----------------------------------------------
set.seed(42)
# locations
nloc = 800
xobs=runif(min=0,max=1,n=nloc)
yobs=runif(min=0,max=1,n=nloc)
loc=cbind(xobs,yobs)
# 2D random field (function f) ------------------------------
a1=-1.5
a2=0.4
z<-function(p)
{
a1*sin(2*pi*p[1])*cos(2*pi*p[2])+a2*sin(3*pi*p[1]) - 2
}
# exact solution
sol_exact=rep(0,length(loc[,1]))
for(i in 1:length(loc[,1])){
sol_exact[i] <- z(loc[i,])
}
nnodes = dim(mesh$nodes)[1]
sol_nodes = numeric(nnodes)
for(i in 1:nnodes){
sol_nodes[i] = z(mesh$nodes[i,])
}
range(sol_exact)
param = sol_exact
mu<-inv.link(param)
range(mu)
# sampling response:
set.seed(95)
response <- response <- rexp(nloc, rate = 1/mu)
# Set smoothing parameter
lambda = 10^seq(-5,0,length.out = 20)
#### Test 2.1: Without GCV
output_CPP <- fdaPDE::smooth.FEM(location = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = NULL,
max.steps=15, fam=FAMILY, mu0=NULL, scale.param=NULL,
lambda=lambda)
#### Test 2.2: With exact GCV
output_CPP <- fdaPDE::smooth.FEM(location = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = NULL,
max.steps=15, fam=FAMILY, mu0=NULL, scale.param=NULL,
lambda = lambda, lambda.selection.criterion = 'grid', DOF.evaluation = 'exact', lambda.selection.lossfunction = 'GCV')
plot(log10(lambda),output_CPP$optimization$GCV_vector)
image(FEM(output_CPP$fit.FEM$coeff[,output_CPP$optimization$lambda_position],FEMbasis))
image(FEM(sol_nodes, FEMbasis))
#### Test 2.3: With stochastic GCV
output_CPP <- fdaPDE::smooth.FEM(location = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = NULL,
max.steps=15, fam=FAMILY, mu0=NULL, scale.param=NULL,
lambda = lambda, lambda.selection.criterion = 'grid', DOF.evaluation = 'stochastic', lambda.selection.lossfunction = 'GCV')
plot(log10(lambda),output_CPP$optimization$GCV_vector)
image(FEM(output_CPP$fit.FEM$coeff[,output_CPP$optimization$lambda_position],FEMbasis))
image(FEM(sol_nodes, FEMbasis))
#### Test 3: square domain GAMMA family ####
#            locations = nodes
#            laplacian
#            no covariates
#            no BC
#            order FE = 1
#
library(fdaPDE)
rm(list=ls())
graphics.off()
FAMILY = "gamma"
link<-function(x){-1/x}
inv.link<-link
# mesh
x = seq(0,1, length.out = 40)
y = x
locations = expand.grid(x,y)
mesh = create.mesh.2D(locations)
plot(mesh)
nnodes = dim(mesh$nodes)[1]
FEMbasis = create.FEM.basis(mesh)
set.seed(42)
# locations
nloc = 800
xobs=runif(min=0,max=1,n=nloc)
yobs=runif(min=0,max=1,n=nloc)
loc=cbind(xobs,yobs)
# 2D random field (function f)
a1=-1.5
a2=0.4
z<-function(p)
{
a1*sin(2*pi*p[1])*cos(2*pi*p[2])+a2*sin(3*pi*p[1]) - 2
}
# exact solution
sol_exact=rep(0,length(loc[,1]))
for(i in 1:length(loc[,1])){
sol_exact[i] <- z(loc[i,])
}
nnodes = dim(mesh$nodes)[1]
sol_nodes = numeric(nnodes)
for(i in 1:nnodes){
sol_nodes[i] = z(mesh$nodes[i,])
}
range(sol_exact)
param = sol_exact
mu<-inv.link(param)
range(mu)
# sampling response:
set.seed(95)
scale.param=1
response <- rgamma(length(loc[,1]), shape=mu/scale.param, scale=scale.param)
# Set smoothing parameter
lambda = 10^seq(-5,0,length.out = 20)
#### Test 3.1: Without GCV
output_CPP <- fdaPDE::smooth.FEM(location = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = NULL,
max.steps=15, fam=FAMILY, mu0=NULL, scale.param=NULL,
lambda = lambda)
#### Test 3.2: With exact GCV
output_CPP <- fdaPDE::smooth.FEM(location = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = NULL,
max.steps=15, fam=FAMILY, mu0=NULL, scale.param=NULL,
lambda = lambda, lambda.selection.criterion = 'grid', DOF.evaluation = 'exact', lambda.selection.lossfunction = 'GCV')
plot(log10(lambda),output_CPP$optimization$GCV_vector)
image(FEM(output_CPP$fit.FEM$coeff[,output_CPP$optimization$lambda_position],FEMbasis))
image(FEM(sol_nodes, FEMbasis))
#### Test 3.3: With stochastic GCV
output_CPP <- fdaPDE::smooth.FEM(location = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = NULL,
max.steps=15, fam=FAMILY, mu0=NULL, scale.param=NULL,
lambda = lambda, lambda.selection.criterion = 'grid', DOF.evaluation = 'stochastic', lambda.selection.lossfunction = 'GCV')
plot(log10(lambda),output_CPP$optimization$GCV_vector)
image(FEM(output_CPP$fit.FEM$coeff[,output_CPP$optimization$lambda_position],FEMbasis))
image(FEM(sol_nodes, FEMbasis))
#### Test 4: square domain POISSON family ####
#            locations = nodes
#            laplacian
#            no covariates
#            no BC
#            order FE = 1
#
library(fdaPDE)
rm(list=ls())
graphics.off()
FAMILY = "poisson"
l<-make.link("log")
link<-l$linkfun
inv.link<-l$linkinv
# mesh
x = seq(0,1, length.out = 40)
y = x
locations = expand.grid(x,y)
mesh = create.mesh.2D(locations)
plot(mesh)
nnodes = dim(mesh$nodes)[1]
FEMbasis = create.FEM.basis(mesh)
set.seed(42)
# locations
nloc = 800
xobs=runif(min=0,max=1,n=nloc)
yobs=runif(min=0,max=1,n=nloc)
loc=cbind(xobs,yobs)
# 2D random field (function f)
a1=-1.5
a2=0.4
z<-function(p)
{
a1*sin(2*pi*p[1])*cos(2*pi*p[2])+a2*sin(3*pi*p[1]) + 2
}
# exact solution
sol_exact=rep(0,length(loc[,1]))
for(i in 1:length(loc[,1])){
sol_exact[i] <- z(loc[i,])
}
nnodes = dim(mesh$nodes)[1]
sol_nodes = numeric(nnodes)
for(i in 1:nnodes){
sol_nodes[i] = z(mesh$nodes[i,])
}
range(sol_exact)
param = sol_exact
mu<-inv.link(param)
range(mu)
# sampling response:
set.seed(95)
response <- rpois(length(loc[,1]), lambda = mu)
# Set smoothing parameter
lambda = 10^seq(-5,0,length.out = 20)
#### Test 4.1: Without GCV
output_CPP <- fdaPDE::smooth.FEM(location = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = NULL,
max.steps=15, fam=FAMILY, mu0=NULL, scale.param=NULL,
lambda=lambda)
image(output_CPP$fit.FEM)
#### Test 4.2: With exact GCV
output_CPP <- fdaPDE::smooth.FEM(location = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = NULL,
max.steps=15, fam=FAMILY, mu0=NULL, scale.param=NULL,
lambda = lambda, lambda.selection.criterion = 'grid', DOF.evaluation = 'exact', lambda.selection.lossfunction = 'GCV')
plot(log10(lambda),output_CPP$optimization$GCV_vector)
image(FEM(output_CPP$fit.FEM$coeff[,output_CPP$optimization$lambda_position],FEMbasis))
image(FEM(sol_nodes, FEMbasis))
#### Test 4.3: With stochastic GCV
output_CPP <- fdaPDE::smooth.FEM(location = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = NULL,
max.steps=15, fam=FAMILY, mu0=NULL, scale.param=NULL,
lambda = lambda, lambda.selection.criterion = 'grid', DOF.evaluation = 'stochastic', lambda.selection.lossfunction = 'GCV' )
plot(log10(lambda),output_CPP$optimization$GCV_vector)
image(FEM(output_CPP$fit.FEM$coeff[,output_CPP$optimization$lambda_position],FEMbasis))
image(FEM(sol_nodes, FEMbasis))
####### 2.5D ########
#### Test 1: HUB (2.5D) POISSON family ####
#            locations = nodes
#            with covariates
#            no BC
library(fdaPDE)
library(purrr)
rm(list=ls())
graphics.off()
# family
FAMILY = "poisson"
l<-make.link("log")
link<-l$linkfun
inv.link<-l$linkinv
# beta
beta1 = 2
beta2 = -3
betas_truth = c(beta1,beta2)
# lambda
lambda = c(0.0001,0.001,0.005,0.006,0.007,0.008,0.009,0.0095,
0.00975,0.01,0.0125,0.015,0.02,0.03,0.04,0.05,0.1,
1,10,100,1000)
# scale param
scale.param = 1
# mesh
data(hub2.5D)
mesh <- create.mesh.2.5D(nodes = hub2.5D$hub2.5D.nodes,triangles = hub2.5D$hub2.5D.triangles)
FEMbasis <- create.FEM.basis(mesh)
# locations
loc = mesh$nodes
nloc = dim(loc)[1]
# 2.5D random field (function f)
a1 = rnorm(1,mean = 0, sd = 1)
a2 = rnorm(1,mean = 0, sd = 1)
a3 = rnorm(1,mean = 0, sd = 1)
sol_exact = numeric(nloc)
for (i in 0:(nloc-1)){
sol_exact[i+1] = a1* sin(2*pi*loc[i+1,1]) +  a2* sin(2*pi*loc[i+1,2]) +  a3*sin(2*pi*loc[i+1,3]) + 7
}
range(sol_exact)
# covariates
set.seed(42)
desmat=matrix(0,nrow=nloc, ncol=2)
desmat[,1]= sin(2*pi*loc[,1])*cos(2*pi*loc[,2])
desmat[,2]= rnorm(nloc, mean=2, sd=0.1)
# samopling response
ran=range(desmat%*%betas_truth + sol_exact)
param=sol_exact+beta1*desmat[,1]+beta2*desmat[,2]
mu<-inv.link(param)
range(mu)
response <- rpois(nloc, lambda = mu)
# Plot the True Field
plot(FEM(sol_exact, FEMbasis))
#### Test 1.1: Without GCV
output_CPP<- smooth.FEM(location = NULL, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = desmat,
max.steps=15, family=FAMILY, mu0=NULL, scale.param=NULL,
lambda = lambda)
#### Test 1.2: grid with exact GCV
output_CPP<- smooth.FEM(location = NULL, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = desmat,
max.steps=15, family=FAMILY, mu0=NULL, scale.param=NULL,
lambda = lambda, lambda.selection.criterion = 'grid', DOF.evaluation = 'exact', lambda.selection.lossfunction = 'GCV')
plot(log10(lambda),output_CPP$optimization$GCV_vector)
beta = output_CPP$solution$beta
func_estimation= output_CPP$fit.FEM$coeff[,output_CPP$bestlambda]
func_estimation= output_CPP$fit.FEM$coeff[,output_CPP$optimization$lambda_position]
plot(FEM(func_estimation,FEMbasis))
# Plot the True Field
plot(FEM(sol_exact, FEMbasis))
#### Test 1.3: grid with stochastic GCV
output_CPP <- smooth.FEM(location = NULL, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = desmat,
max.steps=15, family=FAMILY, mu0=NULL, scale.param=NULL,
lambda = lambda, lambda.selection.criterion = 'grid', DOF.evaluation = 'stochastic', lambda.selection.lossfunction = 'GCV')
plot(log10(lambda),output_CPP$optimization$GCV_vector)
beta = output_CPP$solution$beta
func_estimation= output_CPP$fit.FEM$coeff[,output_CPP$optimization$lambda_position]
plot(FEM(func_estimation,FEMbasis))
library(fdaPDE)
library(purrr)
rm(list=ls())
graphics.off()
# family
FAMILY = "gamma"
link<-function(x){-1/x}
inv.link<-link
# beta
beta1=0.8
beta2=1.2
beta_exact=c(beta1,beta2)
# lambda
lambda = 10^seq(-1,3,length.out = 10)
# scale param
scale.param = 1
data(sphere3Ddata)
sphere3D<-create.mesh.3D(sphere3Ddata$nodes, sphere3Ddata$tetrahedrons)
FEMbasis <- fdaPDE::create.FEM.basis(sphere3D)
nodesLocations=sphere3D$nodes
set.seed(5847947)
set.seed(42)
# add evaluation points
new_grid3d = cbind(runif(1000,min = -1 , max = 1),runif(1000,min = -1 , max = 1),runif(1000,min = -1 , max = 1))
for(i in 1:length(new_grid3d[,1])){
if(new_grid3d[i,1]^2 + new_grid3d[i,2]^2 + new_grid3d[i,3]^2 >= 0.98){
new_grid3d[i,] <- c(NA,NA,NA)
}
}
new_loc <- matrix(ncol = 3, nrow = sum(!is.na(new_grid3d[,1])))
new_loc[,1] <- new_grid3d[!is.na(new_grid3d[,1]),1]
new_loc[,2] <- new_grid3d[!is.na(new_grid3d[,1]),2]
new_loc[,3] <- new_grid3d[!is.na(new_grid3d[,1]),3]
loc <- rbind(nodesLocations, new_loc)
dim(loc)
# Exact test function - locations at nodes
nnodes = sphere3D$nnodes
nloc = dim(loc)[1]
a1 = rnorm(1,mean = -2, sd = 1/8)
a2 = rnorm(1,mean = -2, sd = 1/8)
a3 = rnorm(1,mean = -2, sd = 1/8)
a1 = -1
a2 = -2
a3 = -3
func_evaluation = numeric(nloc)
for (i in 0:(nloc-1)){
func_evaluation[i+1] = a1* sin(loc[i+1,1]) +  a2* sin(loc[i+1,2]) +  a3*sin(loc[i+1,3]) - 7
}
ran=range(func_evaluation)
ran
# covariates
cov1_nonod=sin(2*pi*loc[,1])+sin((2*pi*loc[,2])^2)
cov2_nonod=cos(-2*pi*loc[,3])
plot(FEM(cov1_nonod[1:nnodes], FEMbasis))
plot(FEM(cov2_nonod[1:nnodes], FEMbasis))
W2=cbind(cov1_nonod,cov2_nonod)
# Evaluation on a planar cut [?? purpose]
{
grid_planar_ = cbind(runif(1000,min = -1 , max = 1),runif(1000,min = -1 , max = 1))
radius = 1
for(i in 1:length(grid_planar_[,1])){
if(grid_planar_[i,1]^2+grid_planar_[i,2]^2 >= radius){
grid_planar_[i,] <- c(NA,NA)
}
}
grid_planar <- matrix(ncol=2, nrow = sum(!is.na(grid_planar_[,1])))
grid_planar[,1] <- grid_planar_[!is.na(grid_planar_[,1]),1]
grid_planar[,2] <- grid_planar_[!is.na(grid_planar_[,2]),2]
cov1_planar=sin(2*pi*grid_planar[,1])+sin((2*pi*grid_planar[,2])^2)
meshgrid2d <- create.mesh.2D(nodes=grid_planar)
plot(meshgrid2d)
FEM_basis_planar = fdaPDE::create.FEM.basis(meshgrid2d)
image(FEM(cov1_planar, FEM_basis_planar))
}
range(W2%*%beta_exact + func_evaluation)
# data generation
theta = func_evaluation + W2%*%beta_exact
plot(FEM(theta[1:nnodes], FEMbasis))
mu = inv.link(theta)
plot(FEM(mu[1:nnodes], FEMbasis))
range(mu)
response <- rgamma(length(loc[,1]), shape=mu/scale.param, scale=scale.param)
# Plot the True Field
plot(FEM(response[1:nnodes],FEMbasis))
#### Test 1.1: Without GCV
output_CPP <- smooth.FEM(locations = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = W2,
max.steps=15, family=FAMILY, mu0=NULL, scale.param=NULL,
lambda = lambda)
#### Test 1.2: grid with exact GCV
output_CPP <- smooth.FEM(locations = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = W2,
max.steps=15, family =FAMILY, mu0=NULL, scale.param=NULL,
lambda = lambda, lambda.selection.criterion = 'grid', DOF.evaluation = 'exact', lambda.selection.lossfunction = 'GCV', GCV.inflation.factor = 1)
plot(log10(lambda),output_CPP$optimization$GCV_vector)
beta = output_CPP$solution$beta
func_estimation = output_CPP$fit.FEM$coeff[,output_CPP$optimization$lambda_position]
plot(FEM(func_estimation,FEMbasis))
beta
lambda
#### Test 1.3: grid with stochastic GCV
output_CPP <- smooth.FEM(locations = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = W2,
max.steps=15, family = FAMILY, mu0=NULL, scale.param=NULL,
lambda = lambda, lambda.selection.criterion = 'grid', DOF.evaluation = 'stochastic', lambda.selection.lossfunction = 'GCV', GCV.inflation.factor = 1)
plot(log10(lambda),output_CPP$GCV)
plot(log10(lambda),output_CPP$optimization$GCV_vector)
beta = output_CPP$solution$beta
func_estimation = output_CPP$fit.FEM$coeff[,output_CPP$optimization$lambda_position]
plot(FEM(func_estimation,FEMbasis))
#### Test 1.3: grid with stochastic GCV
output_CPP <- smooth.FEM(locations = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = W2,
max.steps=15, family = FAMILY, mu0=NULL, scale.param=NULL,
lambda = lambda, lambda.selection.criterion = 'grid', DOF.evaluation = 'stochastic', lambda.selection.lossfunction = 'GCV', GCV.inflation.factor = 1)
plot(log10(lambda),output_CPP$GCV)
plot(log10(lambda),output_CPP$optimization$GCV_vector)
beta = output_CPP$solution$beta
func_estimation = output_CPP$fit.FEM$coeff[,output_CPP$optimization$lambda_position]
plot(FEM(func_estimation,FEMbasis))
plot(log10(lambda),output_CPP$optimization$GCV_vector)
beta = output_CPP$solution$beta
func_estimation = output_CPP$fit.FEM$coeff[,output_CPP$optimization$lambda_position]
plot(FEM(func_estimation,FEMbasis))
output_CPP <- smooth.FEM(locations = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = W2,
max.steps=15, family =FAMILY, mu0=NULL, scale.param=NULL,
lambda = lambda, lambda.selection.criterion = 'grid', DOF.evaluation = 'exact', lambda.selection.lossfunction = 'GCV', GCV.inflation.factor = 1)
plot(log10(lambda),output_CPP$optimization$GCV_vector)
beta = output_CPP$solution$beta
func_estimation = output_CPP$fit.FEM$coeff[,output_CPP$optimization$lambda_position]
plot(FEM(func_estimation,FEMbasis))
#### Test 1.3: grid with stochastic GCV
output_CPP <- smooth.FEM(locations = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = W2,
max.steps=15, family = FAMILY, mu0=NULL, scale.param=NULL,
lambda = lambda, lambda.selection.criterion = 'grid', DOF.evaluation = 'stochastic', lambda.selection.lossfunction = 'GCV', GCV.inflation.factor = 1)
plot(log10(lambda),output_CPP$optimization$GCV_vector)
beta = output_CPP$solution$beta
func_estimation = output_CPP$fit.FEM$coeff[,output_CPP$optimization$lambda_position]
plot(FEM(func_estimation,FEMbasis))
output_CPP <- smooth.FEM(locations = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = W2,
max.steps=15, family = FAMILY, mu0=NULL, scale.param=NULL,
lambda = lambda, lambda.selection.criterion = 'grid', DOF.evaluation = 'stochastic', lambda.selection.lossfunction = 'GCV', GCV.inflation.factor = 1, DOF.stochastic.realizations = 1000)
plot(log10(lambda),output_CPP$optimization$GCV_vector)
beta = output_CPP$solution$beta
func_estimation = output_CPP$fit.FEM$coeff[,output_CPP$optimization$lambda_position]
plot(FEM(func_estimation,FEMbasis))
