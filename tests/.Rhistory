lambda = 10^seq(-8,3,length.out = 20)
# scale param
scale.param = 1
#data(AREAL_MeshC)
data(horseshoe2D)
mesh = create.mesh.2D(nodes=horseshoe2D$boundary_nodes, segments = horseshoe2D$boundary_segments)
mesh = refine.mesh.2D(mesh, maximum_area = 0.041, minimum_angle = 30)
mesh = refine.mesh.2D(mesh, maximum_area = 0.041, minimum_angle = 30)
mesh = refine.mesh.2D(mesh, maximum_area = 0.042, minimum_angle = 30)
data(horseshoe2D)
mesh = create.mesh.2D(nodes=horseshoe2D$boundary_nodes, segments = horseshoe2D$boundary_segments)
mesh = refine.mesh.2D(mesh, maximum_area = 0.042, minimum_angle = 30)
data(horseshoe2D)
mesh = create.mesh.2D(nodes=horseshoe2D$boundary_nodes, segments = horseshoe2D$boundary_segments)
mesh = refine.mesh.2D(mesh, maximum_area = 0.045, minimum_angle = 30)
data(horseshoe2D)
mesh = create.mesh.2D(nodes=horseshoe2D$boundary_nodes, segments = horseshoe2D$boundary_segments)
mesh = refine.mesh.2D(mesh, maximum_area = 0.044, minimum_angle = 30)
View(mesh)
rm(list=ls())
graphics.off()
library(fdaPDE)
library(purrr)
library(pracma)
library(ggplot2)
# FAMILY CHOICE
FAMILY = "poisson"
l<-make.link("log")
link<-l$linkfun
inv.link<-l$linkinv
# BETA
beta1= 5
# lambda
lambda = 10^seq(-8,3,length.out = 20)
# scale param
scale.param = 1
#data(AREAL_MeshC)
data(horseshoe2D)
mesh = create.mesh.2D(nodes=horseshoe2D$boundary_nodes, segments = horseshoe2D$boundary_segments)
mesh = refine.mesh.2D(mesh, maximum_area = 0.044, minimum_angle = 30)
nodes = mesh$nodes
#load("../data/meshC_areal.RData")
# x11()
plot(mesh, lwd=3, cex = 1.9)
nnodes = dim(mesh$nodes)[1]
FEMbasis = fdaPDE::create.FEM.basis(mesh)
# 2D random field (function f) ------------------------------
a_fun <- function(p){
if(p[1]>= 0 && p[2] > 0){
pi/4 + p[1]
}else{
if(p[1]>= 0 && p[2] <= 0){
-pi/4 -p[1]
}else{
if(p[1] < 0){
-0.5*atan(p[2]/p[1])
}
}
}
}
d_fun <- function(p){
if(p[1]>= 0 && p[2] > 0){
-0.5 + p[2]
}else{
if(p[1]>= 0 && p[2] <= 0){
-0.5 - p[2]
}else{
if(p[1] < 0){
sqrt(p[1]^2 + p[2]^2) - 0.5
}
}
}
}
z <- function(p){
a_fun(p) + d_fun(p)^2
}
list_of_ones = c(239, 244, 596, 602, 898, 900, 1256, 1258, 1504, 1517,
1838, 1839, 2172, 2173, 2497, 2498, 2796, 2848, 3125,
3128, 3482, 3491, 3857, 3859, 4191, 4212, 4542, 4543,
4892, 4985, 5343, 5345, 5698, 5706, 6030, 6053, 6402,
6404, 6763, 6775)
tri = mesh$triangles
incidence_matrix = zeros(dim(tri)[1],length(lambda))
incidence_matrix[list_of_ones]=1
dim(incidence_matrix)
dim(tri)
integration_nodes = data.frame(matrix(nrow = dim(incidence_matrix)[2],ncol = 11))
names(integration_nodes) = c("T1","T2","N1","N2","N3","N4", "xmin", "xmax", "ymin", "ymax", "label")
nodi_plot = NULL
for(i in 1:dim(incidence_matrix)[2]){
tri_used = which(incidence_matrix[,i] == 1)
integration_nodes$T1[i] = tri_used[1]
integration_nodes$T2[i] = tri_used[2]
nodes_used = unique(c(tri[tri_used[1],],tri[tri_used[2],]))
integration_nodes$N1[i] = nodes_used[1]
integration_nodes$N2[i] = nodes_used[2]
integration_nodes$N3[i] = nodes_used[3]
integration_nodes$N4[i] = nodes_used[4]
integration_nodes$label[i] = i
xvec = c(nodes[integration_nodes$N1[i],1],nodes[integration_nodes$N2[i],1],nodes[integration_nodes$N3[i],1],nodes[integration_nodes$N4[i],1])
yvec = c(nodes[integration_nodes$N1[i],2],nodes[integration_nodes$N2[i],2],nodes[integration_nodes$N3[i],2],nodes[integration_nodes$N4[i],2])
integration_nodes$xmin[i] = min(xvec)
integration_nodes$xmax[i] = max(xvec)
integration_nodes$ymin[i] = min(yvec)
integration_nodes$ymax[i] = max(yvec)
nodi_tmp = rbind(mesh$nodes[integration_nodes$N1[i],],mesh$nodes[integration_nodes$N2[i],],mesh$nodes[integration_nodes$N3[i],],mesh$nodes[integration_nodes$N4[i],])
nodi_tmp = cbind(nodi_tmp,rep(i,4))
nodi_plot = rbind(nodi_plot,nodi_tmp)
}
incidence_matrix
# TESTS FOR MESH C 2D AREAL DATA
rm(list=ls())
graphics.off()
library(fdaPDE)
library(purrr)
library(pracma)
library(ggplot2)
# FAMILY CHOICE
FAMILY = "poisson"
l<-make.link("log")
link<-l$linkfun
inv.link<-l$linkinv
# BETA
beta1= 5
# lambda
lambda = 10^seq(-8,3,length.out = 20)
# scale param
scale.param = 1
#data(AREAL_MeshC)
data(horseshoe2D)
mesh = create.mesh.2D(nodes=horseshoe2D$boundary_nodes, segments = horseshoe2D$boundary_segments)
mesh = refine.mesh.2D(mesh, maximum_area = 0.044, minimum_angle = 30)
nodes = mesh$nodes
# x11()
plot(mesh, lwd=3, cex = 1.9)
nnodes = dim(mesh$nodes)[1]
FEMbasis = fdaPDE::create.FEM.basis(mesh)
# 2D random field (function f) ------------------------------
a_fun <- function(p){
if(p[1]>= 0 && p[2] > 0){
pi/4 + p[1]
}else{
if(p[1]>= 0 && p[2] <= 0){
-pi/4 -p[1]
}else{
if(p[1] < 0){
-0.5*atan(p[2]/p[1])
}
}
}
}
d_fun <- function(p){
if(p[1]>= 0 && p[2] > 0){
-0.5 + p[2]
}else{
if(p[1]>= 0 && p[2] <= 0){
-0.5 - p[2]
}else{
if(p[1] < 0){
sqrt(p[1]^2 + p[2]^2) - 0.5
}
}
}
}
z <- function(p){
a_fun(p) + d_fun(p)^2
}
list_of_ones = c(239, 244, 596, 602, 898, 900, 1256, 1258, 1504, 1517,
1838, 1839, 2172, 2173, 2497, 2498, 2796, 2848, 3125,
3128, 3482, 3491, 3857, 3859, 4191, 4212, 4542, 4543,
4892, 4985, 5343, 5345, 5698, 5706, 6030, 6053, 6402,
6404, 6763, 6775)
tri = mesh$triangles
incidence_matrix = zeros(dim(tri)[1],length(lambda))
incidence_matrix[list_of_ones]=1
incidence_matrix=matrix(incidence_matrix,nrow=dim(tri)[1],ncol=length(lambda))
7 %5
7 mod5
7 %% 5
list_of_ones = c(239, 244, 596, 602, 898, 900, 1256, 1258, 1504, 1517,
1838, 1839, 2172, 2173, 2497, 2498, 2796, 2848, 3125,
3128, 3482, 3491, 3857, 3859, 4191, 4212, 4542, 4543,
4892, 4985, 5343, 5345, 5698, 5706, 6030, 6053, 6402,
6404, 6763, 6775)
tri = mesh$triangles
incidence_matrix = zeros(dim(tri)[1],length(lambda))
for(ii in 1:dim(tri)[1]*length(lambda))
for(ii in 1:dim(tri)[1]*length(lambda))
{
j=1
if(ii %in% v)
{
incidence_matrix[list_of_ones[j]%/%length(lambda), list_of_ones[j]%%length(lambda)] =1
j=j+1
}
}
incidence_matrix = zeros(dim(tri)[1],length(lambda))
for(ii in 1:dim(tri)[1]*length(lambda))
{
j=1
if(ii %in% list_of_ones)
{
incidence_matrix[list_of_ones[j]%/%length(lambda), list_of_ones[j]%%length(lambda)] =1
j=j+1
}
}
incidence_matrix
which(incidence_matrix==1)
list_of_ones[j]%/%length(lambda)
list_of_ones[j]%%length(lambda)
dim(tri)[1]*length(lambda)
incidence_matrix[list_of_ones[j]%/%length(lambda), list_of_ones[j]%%length(lambda)]
# family
FAMILY = "gamma"
link<-function(x){-1/x}
inv.link<-link
beta1=0.8
beta2=1.2
beta_exact=c(beta1,beta2)
data(sphere3Ddata)
library(fdaPDE)
data(sphere3Ddata)
sphere3D<-create.mesh.3D(sphere3Ddata$nodes, sphere3Ddata$tetrahedrons)
FEMbasis <- fdaPDE::create.FEM.basis(sphere3D)
nodesLocations=sphere3D$nodes
set.seed(5847947)
set.seed(42)
###############################################
############# TEST SCRIPT GAM 3D ##############
###############################################
####### 3D ########
#### Test 1: Sphere 3D GAMMA family ####
#            locations not at nodes
#            with covariates
#            no BC
library(fdaPDE)
library(purrr)
rm(list=ls())
graphics.off()
# family
FAMILY = "gamma"
link<-function(x){-1/x}
inv.link<-link
# beta
beta1=0.8
beta2=1.2
beta_exact=c(beta1,beta2)
# lambda
lambda = 10^seq(-1,3,length.out = 10)
# scale param
scale.param = 1
data(sphere3Ddata)
sphere3D<-create.mesh.3D(sphere3Ddata$nodes, sphere3Ddata$tetrahedrons)
FEMbasis <- fdaPDE::create.FEM.basis(sphere3D)
nodesLocations=sphere3D$nodes
set.seed(5847947)
set.seed(42)
# add evaluation points
new_grid3d = cbind(runif(1000,min = -1 , max = 1),runif(1000,min = -1 , max = 1),runif(1000,min = -1 , max = 1))
for(i in 1:length(new_grid3d[,1])){
if(new_grid3d[i,1]^2 + new_grid3d[i,2]^2 + new_grid3d[i,3]^2 >= 0.98){
new_grid3d[i,] <- c(NA,NA,NA)
}
}
new_loc <- matrix(ncol = 3, nrow = sum(!is.na(new_grid3d[,1])))
new_loc[,1] <- new_grid3d[!is.na(new_grid3d[,1]),1]
new_loc[,2] <- new_grid3d[!is.na(new_grid3d[,1]),2]
new_loc[,3] <- new_grid3d[!is.na(new_grid3d[,1]),3]
loc <- rbind(nodesLocations, new_loc)
dim(loc)
# Exact test function - locations at nodes
nnodes = sphere3D$nnodes
nloc = dim(loc)[1]
a1 = rnorm(1,mean = -2, sd = 1/8)
a2 = rnorm(1,mean = -2, sd = 1/8)
a3 = rnorm(1,mean = -2, sd = 1/8)
a1 = -1
a2 = -2
a3 = -3
func_evaluation = numeric(nloc)
for (i in 0:(nloc-1)){
func_evaluation[i+1] = a1* sin(loc[i+1,1]) +  a2* sin(loc[i+1,2]) +  a3*sin(loc[i+1,3]) - 7
}
ran=range(func_evaluation)
ran
# covariates
cov1_nonod=sin(2*pi*loc[,1])+sin((2*pi*loc[,2])^2)
cov2_nonod=cos(-2*pi*loc[,3])
plot(FEM(cov1_nonod[1:nnodes], FEMbasis))
plot(FEM(cov2_nonod[1:nnodes], FEMbasis))
W2=cbind(cov1_nonod,cov2_nonod)
# Evaluation on a planar cut
{
grid_planar_ = cbind(runif(1000,min = -1 , max = 1),runif(1000,min = -1 , max = 1))
radius = 1
for(i in 1:length(grid_planar_[,1])){
if(grid_planar_[i,1]^2+grid_planar_[i,2]^2 >= radius){
grid_planar_[i,] <- c(NA,NA)
}
}
grid_planar <- matrix(ncol=2, nrow = sum(!is.na(grid_planar_[,1])))
grid_planar[,1] <- grid_planar_[!is.na(grid_planar_[,1]),1]
grid_planar[,2] <- grid_planar_[!is.na(grid_planar_[,2]),2]
cov1_planar=sin(2*pi*grid_planar[,1])+sin((2*pi*grid_planar[,2])^2)
meshgrid2d <- create.mesh.2D(nodes=grid_planar)
plot(meshgrid2d)
FEM_basis_planar = fdaPDE::create.FEM.basis(meshgrid2d)
image(FEM(cov1_planar, FEM_basis_planar))
}
range(W2%*%beta_exact + func_evaluation)
theta = func_evaluation + W2%*%beta_exact
plot(FEM(theta[1:nnodes], FEMbasis))
{
grid_planar_ = cbind(runif(1000,min = -1 , max = 1),runif(1000,min = -1 , max = 1))
radius = 1
for(i in 1:length(grid_planar_[,1])){
if(grid_planar_[i,1]^2+grid_planar_[i,2]^2 >= radius){
grid_planar_[i,] <- c(NA,NA)
}
}
grid_planar <- matrix(ncol=2, nrow = sum(!is.na(grid_planar_[,1])))
grid_planar[,1] <- grid_planar_[!is.na(grid_planar_[,1]),1]
grid_planar[,2] <- grid_planar_[!is.na(grid_planar_[,2]),2]
cov1_planar=sin(2*pi*grid_planar[,1])+sin((2*pi*grid_planar[,2])^2)
meshgrid2d <- create.mesh.2D(nodes=grid_planar)
plot(meshgrid2d)
FEM_basis_planar = fdaPDE::create.FEM.basis(meshgrid2d)
image(FEM(cov1_planar, FEM_basis_planar))
}
####### 3D ########
#### Test 1: Sphere 3D GAMMA family ####
#            locations not at nodes
#            with covariates
#            no BC
library(fdaPDE)
library(purrr)
rm(list=ls())
graphics.off()
# family
FAMILY = "gamma"
link<-function(x){-1/x}
inv.link<-link
# beta
beta1=0.8
beta2=1.2
beta_exact=c(beta1,beta2)
# lambda
lambda = 10^seq(-1,3,length.out = 10)
# scale param
scale.param = 1
data(sphere3Ddata)
sphere3D<-create.mesh.3D(sphere3Ddata$nodes, sphere3Ddata$tetrahedrons)
FEMbasis <- fdaPDE::create.FEM.basis(sphere3D)
nodesLocations=sphere3D$nodes
set.seed(5847947)
set.seed(42)
# add evaluation points
new_grid3d = cbind(runif(1000,min = -1 , max = 1),runif(1000,min = -1 , max = 1),runif(1000,min = -1 , max = 1))
for(i in 1:length(new_grid3d[,1])){
if(new_grid3d[i,1]^2 + new_grid3d[i,2]^2 + new_grid3d[i,3]^2 >= 0.98){
new_grid3d[i,] <- c(NA,NA,NA)
}
}
new_loc <- matrix(ncol = 3, nrow = sum(!is.na(new_grid3d[,1])))
new_loc[,1] <- new_grid3d[!is.na(new_grid3d[,1]),1]
new_loc[,2] <- new_grid3d[!is.na(new_grid3d[,1]),2]
new_loc[,3] <- new_grid3d[!is.na(new_grid3d[,1]),3]
loc <- rbind(nodesLocations, new_loc)
dim(loc)
# Exact test function - locations at nodes
nnodes = sphere3D$nnodes
nloc = dim(loc)[1]
a1 = rnorm(1,mean = -2, sd = 1/8)
a2 = rnorm(1,mean = -2, sd = 1/8)
a3 = rnorm(1,mean = -2, sd = 1/8)
a1 = -1
a2 = -2
a3 = -3
func_evaluation = numeric(nloc)
for (i in 0:(nloc-1)){
func_evaluation[i+1] = a1* sin(loc[i+1,1]) +  a2* sin(loc[i+1,2]) +  a3*sin(loc[i+1,3]) - 7
}
ran=range(func_evaluation)
ran
# covariates
cov1_nonod=sin(2*pi*loc[,1])+sin((2*pi*loc[,2])^2)
cov2_nonod=cos(-2*pi*loc[,3])
plot(FEM(cov1_nonod[1:nnodes], FEMbasis))
plot(FEM(cov2_nonod[1:nnodes], FEMbasis))
W2=cbind(cov1_nonod,cov2_nonod)
# data generation
theta = func_evaluation + W2%*%beta_exact
plot(FEM(theta[1:nnodes], FEMbasis))
mu = inv.link(theta)
plot(FEM(mu[1:nnodes], FEMbasis))
range(mu)
response <- rgamma(length(loc[,1]), shape=mu/scale.param, scale=scale.param)
plot(FEM(response[1:nnodes],FEMbasis))
output_CPP <- fdaPDE::smooth.FEM(locations = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = W2, GCV=GCVFLAG, GCVmethod = GCVmethod,
lambda = lambda, max.steps=15, fam=FAMILY, mu0=NULL, scale.param=NULL,tune=1)
# data generation
theta = func_evaluation + W2%*%beta_exact
plot(FEM(theta[1:nnodes], FEMbasis))
mu = inv.link(theta)
plot(FEM(mu[1:nnodes], FEMbasis))
range(mu)
response <- rgamma(length(loc[,1]), shape=mu/scale.param, scale=scale.param)
plot(FEM(response[1:nnodes],FEMbasis))
library(fdaPDE)
library(purrr)
rm(list=ls())
graphics.off()
# family
FAMILY = "gamma"
link<-function(x){-1/x}
inv.link<-link
# beta
beta1=0.8
beta2=1.2
beta_exact=c(beta1,beta2)
# lambda
lambda = 10^seq(-1,3,length.out = 10)
# scale param
scale.param = 1
data(sphere3Ddata)
sphere3D<-create.mesh.3D(sphere3Ddata$nodes, sphere3Ddata$tetrahedrons)
FEMbasis <- fdaPDE::create.FEM.basis(sphere3D)
nodesLocations=sphere3D$nodes
set.seed(5847947)
set.seed(42)
# add evaluation points
new_grid3d = cbind(runif(1000,min = -1 , max = 1),runif(1000,min = -1 , max = 1),runif(1000,min = -1 , max = 1))
for(i in 1:length(new_grid3d[,1])){
if(new_grid3d[i,1]^2 + new_grid3d[i,2]^2 + new_grid3d[i,3]^2 >= 0.98){
new_grid3d[i,] <- c(NA,NA,NA)
}
}
new_loc <- matrix(ncol = 3, nrow = sum(!is.na(new_grid3d[,1])))
new_loc[,1] <- new_grid3d[!is.na(new_grid3d[,1]),1]
new_loc[,2] <- new_grid3d[!is.na(new_grid3d[,1]),2]
new_loc[,3] <- new_grid3d[!is.na(new_grid3d[,1]),3]
loc <- rbind(nodesLocations, new_loc)
dim(loc)
# Exact test function - locations at nodes
nnodes = sphere3D$nnodes
nloc = dim(loc)[1]
a1 = rnorm(1,mean = -2, sd = 1/8)
a2 = rnorm(1,mean = -2, sd = 1/8)
a3 = rnorm(1,mean = -2, sd = 1/8)
a1 = -1
a2 = -2
a3 = -3
func_evaluation = numeric(nloc)
for (i in 0:(nloc-1)){
func_evaluation[i+1] = a1* sin(loc[i+1,1]) +  a2* sin(loc[i+1,2]) +  a3*sin(loc[i+1,3]) - 7
}
ran=range(func_evaluation)
ran
# covariates
cov1_nonod=sin(2*pi*loc[,1])+sin((2*pi*loc[,2])^2)
cov2_nonod=cos(-2*pi*loc[,3])
plot(FEM(cov1_nonod[1:nnodes], FEMbasis))
plot(FEM(cov2_nonod[1:nnodes], FEMbasis))
W2=cbind(cov1_nonod,cov2_nonod)
# data generation
theta = func_evaluation + W2%*%beta_exact
plot(FEM(theta[1:nnodes], FEMbasis))
mu = inv.link(theta)
plot(FEM(mu[1:nnodes], FEMbasis))
range(mu)
response <- rgamma(length(loc[,1]), shape=mu/scale.param, scale=scale.param)
plot(FEM(response[1:nnodes],FEMbasis))
# Plot the True Field
plot(FEM(sol_exact, FEMbasis))
#### Test 1.1: Without GCV
output_CPP <- smooth.FEM(locations = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = W2,
max.steps=15, fam=FAMILY, mu0=NULL, scale.param=NULL, tune=1,
lambda = lambda)
help("smooth.FEM")
#### Test 1.1: Without GCV
output_CPP <- smooth.FEM(locations = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = W2,
max.steps=15, family=FAMILY, mu0=NULL, scale.param=NULL,
lambda = lambda)
#### Test 1.2: grid with exact GCV
output_CPP <- smooth.FEM(locations = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = W2,
max.steps=15, fam=FAMILY, mu0=NULL, scale.param=NULL, tune=1,
lambda = lambda, lambda.selection.criterion = 'grid', DOF.evaluation = 'exact', lambda.selection.lossfunction = 'GCV', GCV.inflation.factor = 1)
#### Test 1.2: grid with exact GCV
output_CPP <- smooth.FEM(locations = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = W2,
max.steps=15, fam=FAMILY, mu0=NULL, scale.param=NULL,
lambda = lambda, lambda.selection.criterion = 'grid', DOF.evaluation = 'exact', lambda.selection.lossfunction = 'GCV', GCV.inflation.factor = 1)
#### Test 1.2: grid with exact GCV
output_CPP <- smooth.FEM(locations = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = W2,
max.steps=15, family =FAMILY, mu0=NULL, scale.param=NULL,
lambda = lambda, lambda.selection.criterion = 'grid', DOF.evaluation = 'exact', lambda.selection.lossfunction = 'GCV', GCV.inflation.factor = 1)
plot(log10(lambda),output_CPP$GCV)
beta= output_CPP$beta
func_estimation= output_CPP$fit.FEM$coeff[,output_CPP$bestlambda]
plot(FEM(func_estimation,FEMbasis))
#### Test 1.3: grid with stochastic GCV
output_CPP <- smooth.FEM(locations = loc, observations = as.numeric(response), FEMbasis =FEMbasis, covariates = W2,
max.steps=15, family = FAMILY, mu0=NULL, scale.param=NULL,
lambda = lambda, lambda.selection.criterion = 'grid', DOF.evaluation = 'stochastic', lambda.selection.lossfunction = 'GCV', GCV.inflation.factor = 1)
plot(log10(lambda),output_CPP$GCV)
beta= output_CPP$beta
func_estimation= output_CPP$fit.FEM$coeff[,output_CPP$bestlambda]
plot(FEM(func_estimation,FEMbasis))
# Plot the True Field
plot(FEM(response[1:nnodes],FEMbasis))
beta= output_CPP$beta
beta
load("/home/giorgio/Desktop/pacs project/fdaPDE/data/horseshoe2D_areal.RData")
